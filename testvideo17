% process_experimental_nah_esm_multimethod.m
% NOW INCLUDES MULTI-LAYER CAPABILITY (TMM Analytical Model)
% AND OPTIONAL K-WAVE PROPAGATOR COMPUTATION.
% Uses Green_matrix_multilayer_TMM OR compute_H_kwave. %%% <<< UPDATED PROPAGATOR
% Includes frequency-dependent attenuation power law.
% Uses enhanced SBL stopping. Caching implemented for k-Wave results.
% Enhancements: Robust GA objective (using Tikhonov/TMM), improved SBL plotting/stability,
%               functional L1-TV (Split-Bregman), Multi-frequency processing & fusion. %%% <<< NEW FEATURES

    % 1. Sound Speed (c) for the layer.
    %
    % 2. Density (rho) for the layer.
    %
    % 3. Absorption parameters: (alpha_dB_m at alpha_freq_Hz, and alpha_power).
    %
    % 4. Layer thickness.
%% Speed of sound for bark vs frequency
%c =    0.02*f + 375; % pine bark speed of sound equation - transverse

%% 0. Initialization
close all hidden;
clear all;
clc;
global G_curr_condition G_curr_svd_s % Keep for condition analysis plot reusing fig 103

fprintf('--- Starting Experimental Data Processing (NAH) - ESM Multi-Method (TMM / k-Wave / Multi-Freq) ---\n'); %%% <<< UPDATED TITLE

% --- Check Toolboxes ---
% (Identical to previous corrected version - omitted for brevity)
fprintf('Checking for required toolboxes...\n');
requiredToolboxes = { % Use official Product Names for license check
    'Signal Processing Toolbox', 'Signal_Toolbox'; % Name, License Check Name
    'Image Processing Toolbox',  'Image_Toolbox';
    'Parallel Computing Toolbox','Distrib_Computing_Toolbox'; % Note: Parallel uses Distrib_Computing_Toolbox license name
    'Global Optimization Toolbox','GADS_Toolbox';            % Note: GA uses GADS_Toolbox license name
    'Statistics and Machine Learning Toolbox', 'Statistics_Toolbox' % CORRECTED LICENSE NAME
    };
missingToolboxes = {}; can_run_ga = false; can_run_parallel = false;
for i = 1:size(requiredToolboxes, 1)
    toolboxDisplayName = requiredToolboxes{i, 1}; toolboxLicenseName = requiredToolboxes{i, 2};
    if ~license('test', toolboxLicenseName), missingToolboxes{end+1} = toolboxDisplayName; fprintf(' - MISSING: %s (License: %s)\n', toolboxDisplayName, toolboxLicenseName);
    else fprintf(' - Found:   %s (License: %s)\n', toolboxDisplayName, toolboxLicenseName); if strcmp(toolboxLicenseName, 'GADS_Toolbox'), can_run_ga = true; end; if strcmp(toolboxLicenseName, 'Distrib_Computing_Toolbox'), can_run_parallel = true; end; end
end
if ~isempty(missingToolboxes), warning('Missing toolboxes: %s. Features might be disabled.', strjoin(missingToolboxes, ', ')); else fprintf('All required toolboxes found.\n'); end
if can_run_ga, fprintf(' - Global Optimization Toolbox (GA) available.\n'); else fprintf(' - Global Optimization Toolbox (GA) NOT available. Optimization disabled if selected.\n'); end
if can_run_parallel, fprintf(' - Parallel Computing Toolbox available.\n'); else fprintf(' - Parallel Computing Toolbox NOT available. Parallel features disabled.\n'); end
% --- End Toolbox Check ---

%% 1. Parameters and Configuration
params = struct();

params.optimize_material_properties = false; % SET TO true TO ENABLE GA
ga_active = false; % Flag to track if optimization actually runs

% 1a. Physical Constants & Material Properties Database Function
%params.material_database = create_material_properties(); % Load material data
params.material_database = create_material_properties_with_uncertainty(); 

% --- CORE SETUP ---
fprintf('\n--- User Scenario Setup ---\n');
params.scenario_description = 'Sorama Array, Source behind Layer?, ESM Recon (Multi-Method, TMM/k-Wave, Multi-Freq)'; %%% <<< UPDATED DESC

% --- Propagator Choice ---
fprintf('\n--- Propagator Calculation Method ---\n');
disp('Select method for H_esm / H_r calculation:');
disp('1. Transfer Matrix Method (TMM) Analytical Green Function (Accurate Analytical)'); %%% <<< UPDATED OPTION 1
disp('2. k-Wave Numerical Simulation (MUCH Slower, Full Wave Physics, Requires k-Wave Tbx)');
prop_choice = input('Enter choice (1-2) [Default 1]: ');
if isempty(prop_choice) || prop_choice == 1
    params.use_kwave_propagator = false;
    fprintf(' Using Transfer Matrix Method (TMM) Analytical Green Function.\n'); %%% <<< UPDATED TEXT
elseif prop_choice == 2
    if ~exist('kspaceFirstOrder3D.m', 'file')
        warning('k-Wave function kspaceFirstOrder3D.m not found in path. Defaulting to TMM Analytical Green Function.');
        params.use_kwave_propagator = false;
    else
        params.use_kwave_propagator = true;
        fprintf(' Using k-Wave Numerical Simulation.\n');
    end
else
    warning('Invalid choice. Defaulting to TMM Analytical Green Function.');
    params.use_kwave_propagator = false;
end

% --- Multi-Frequency Processing --- %%% <<< NEW SECTION
fprintf('\n--- Multi-Frequency Processing Setup ---\n');
params.use_multifreq = false; % Default to single frequency (dominant)
multifreq_choice = input('Enable Multi-Frequency Processing & Fusion? (y/N): ', 's');
if ~isempty(multifreq_choice) && lower(multifreq_choice(1)) == 'y'
    params.use_multifreq = true;
    params.num_freq_bins = 5; % Default number of bins to process
    num_bins_in = input(sprintf('Enter number of frequency bins to process/fuse [Default %d]: ', params.num_freq_bins));
    if ~isempty(num_bins_in) && isnumeric(num_bins_in) && num_bins_in > 0
        params.num_freq_bins = round(num_bins_in);
    end
    disp('Select Multi-Frequency Bin Selection Method:');
    disp('1. Top N bins by power [Default]');
    disp('2. All bins within region above power threshold');
    bin_sel_choice = input('Enter choice (1-2) [Default 1]: ');
    if isempty(bin_sel_choice) || bin_sel_choice == 1
        params.multifreq_bin_selection = 'top_n';
        fprintf('   Using Top %d bins by power.\n', params.num_freq_bins);
    elseif bin_sel_choice == 2
        params.multifreq_bin_selection = 'threshold';
        params.multifreq_power_thresh_db = -20; % dB relative to peak power in region
        thresh_in = input(sprintf('Enter power threshold (dB relative to peak) [Default %.1f]: ', params.multifreq_power_thresh_db));
         if ~isempty(thresh_in) && isnumeric(thresh_in) && thresh_in < 0
            params.multifreq_power_thresh_db = thresh_in;
        end
        fprintf('   Using bins with power > %.1f dB relative to peak.\n', params.multifreq_power_thresh_db);
    else
        warning('Invalid choice. Defaulting to Top N bins.');
        params.multifreq_bin_selection = 'top_n';
        fprintf('   Using Top %d bins by power.\n', params.num_freq_bins);
    end

    disp('Select Multi-Frequency Fusion Method:');
    disp('1. Median of normalized maps [Default]');
    disp('2. Mean of normalized maps');
    disp('3. Max of normalized maps');
    fuse_choice = input('Enter choice (1-3) [Default 1]: ');
     if isempty(fuse_choice) || fuse_choice == 1, params.multifreq_fusion_method = 'median';
     elseif fuse_choice == 2, params.multifreq_fusion_method = 'mean';
     elseif fuse_choice == 3, params.multifreq_fusion_method = 'max';
     else warning('Invalid choice. Defaulting to Median.'); params.multifreq_fusion_method = 'median'; end
     fprintf('   Using %s fusion.\n', params.multifreq_fusion_method);

    %%% <<< ADD RESIDUAL THRESHOLD PARAMETER >>>
    params.multifreq_residual_threshold = 0.40; % Default threshold (e.g., 20% residual)
    res_thresh_in = input(sprintf('Enter MAX relative residual for fusion inclusion [Default %.2f]: ', params.multifreq_residual_threshold));
    if ~isempty(res_thresh_in) && isnumeric(res_thresh_in) && res_thresh_in > 0
        params.multifreq_residual_threshold = res_thresh_in;
    end
    fprintf('   Frequencies with relative residual > %.3f will be EXCLUDED from fusion.\n', params.multifreq_residual_threshold);
    %%% <<< END ADDED PARAMETER >>>

else
    fprintf(' Multi-Frequency Processing DISABLED (using dominant frequency only).\n');
end
% --- END Multi-Frequency Section -
% --- END Multi-Frequency Section ---

% --- Minimum Frequency for Analysis --- %%% <<< ADD THIS LINE BACK >>>
params.min_freq_for_analysis = 500; % Or get user input if desired
min_freq_in = input(sprintf('Enter minimum frequency (Hz) to consider for analysis [Default %d]: ', params.min_freq_for_analysis));
if ~isempty(min_freq_in) && isnumeric(min_freq_in) && min_freq_in >= 0
    params.min_freq_for_analysis = min_freq_in;
end
fprintf(' Minimum frequency for analysis set to: %.1f Hz\n', params.min_freq_for_analysis);
% --- END ADDED LINE --

% --- Medium Configuration ---
% (Identical to previous version - omitted for brevity)
fprintf('\n--- Medium Configuration ---\n');
disp('Select Scenario:'); disp('1. Air Only (Free Field)'); disp('2. Source behind Teflon Layer'); disp('3. Source behind Pine Bark Layer');
scenario_choice = input('Enter choice (1-3) [Default 1=Air Only]: '); if isempty(scenario_choice), scenario_choice = 1; end
params.layer_thickness = 0; % Default for air only
switch scenario_choice
    case 1, params.medium_type = 'air_only'; params.layer_material = 'air'; params.layer_thickness = 0; fprintf(' Configuration set to: Air Only.\n');
    case 2, params.medium_type = 'teflon_layer'; params.layer_material = 'teflon'; thick_in = input(' Enter Teflon layer thickness (cm) [e.g., 2]: '); if isempty(thick_in) || thick_in <= 0, error('Valid thickness required.'); end; params.layer_thickness = thick_in / 100; fprintf(' Configuration set to: Source behind %.2f cm Teflon Layer.\n', thick_in);
    case 3, params.medium_type = 'bark_layer'; params.layer_material = 'pine_bark'; thick_in = input(' Enter Pine Bark layer thickness (cm) [e.g., 2]: '); if isempty(thick_in) || thick_in <= 0, error('Valid thickness required.'); end; params.layer_thickness = thick_in / 100; fprintf(' Configuration set to: Source behind %.2f cm Pine Bark Layer.\n', thick_in);
    otherwise, warning('Invalid scenario choice. Defaulting to Air Only.'); params.medium_type = 'air_only'; params.layer_material = 'air'; params.layer_thickness = 0;
end


% --- Geometry Input ---
% (Identical to previous version - omitted for brevity)
fprintf('\n--- Geometry Configuration ---\n');
dist_mic_to_front_surface = input(sprintf('Enter distance from Mic Array (z=0) to FRONT surface of Layer/Object (cm) [e.g., 2]: ')); if isempty(dist_mic_to_front_surface) || dist_mic_to_front_surface <= 0, error('Valid Mic-to-Surface distance required.'); end; params.dist_mic_to_front_surface = dist_mic_to_front_surface / 100; % meters
params.sbl_plot_interval = 20; % Update plot every 20 iterations (adjust as needed)


% --- ESM Plane ---
% (Identical to previous version - omitted for brevity)
params.esm_delta_z_factor = 0.75; delta_z_in = input(sprintf('Enter ESM delta_z factor (relative to dx) [Default %.2f]: ', params.esm_delta_z_factor)); if ~isempty(delta_z_in) && delta_z_in > 0, params.esm_delta_z_factor = delta_z_in; end


% --- k-Wave Specific Parameters ---
% (Identical to previous version - omitted for brevity)
if params.use_kwave_propagator
    fprintf('\n--- k-Wave Simulation Parameters ---\n');
    params.kwave_ppw = 4; kwave_ppw_in = input(sprintf('Enter k-Wave Points Per Wavelength (ppw) [Default %.2f]: ', params.kwave_ppw)); if ~isempty(kwave_ppw_in) && kwave_ppw_in >= 2, params.kwave_ppw = kwave_ppw_in; end
    params.kwave_CFL = 0.1; kwave_cfl_in = input(sprintf('Enter k-Wave CFL number [Default %.2f]: ', params.kwave_CFL)); if ~isempty(kwave_cfl_in) && kwave_cfl_in > 0 && kwave_cfl_in <= 0.3, params.kwave_CFL = kwave_cfl_in; end
    params.kwave_t_end_factor = 1.5; kwave_tf_in = input(sprintf('Enter k-Wave t_end factor [Default %.2f]: ', params.kwave_t_end_factor)); if ~isempty(kwave_tf_in) && kwave_tf_in >= 1, params.kwave_t_end_factor = kwave_tf_in; end
    params.kwave_pml_size = 10; kwave_pml_in = input(sprintf('Enter k-Wave PML size (grid points) [Default %d]: ', params.kwave_pml_size)); if ~isempty(kwave_pml_in) && kwave_pml_in >= 5, params.kwave_pml_size = round(kwave_pml_in); end
    params.kwave_use_gpu = false; gpu_present = false;
    if can_run_parallel, try if gpuDeviceCount > 0, gpu_present = true; gpu_dev = gpuDevice; fprintf(' GPU Detected: %s (Compute Capability %s)\n', gpu_dev.Name, gpu_dev.ComputeCapability); gpu_choice = input('Use GPU for k-Wave simulations? (y/N): ', 's'); if ~isempty(gpu_choice) && lower(gpu_choice(1)) == 'y', params.kwave_use_gpu = true; end; else fprintf(' No compatible GPU detected.\n'); end; catch ME_gpu, fprintf(' Could not query GPU devices (Error: %s).\n', ME_gpu.message); end; else fprintf(' Parallel Tbx license missing. GPU Accel unavailable.\n'); end
    params.kwave_gpu_available_and_selected = gpu_present && params.kwave_use_gpu; if params.kwave_gpu_available_and_selected, fprintf(' GPU acceleration for k-Wave ENABLED.\n'); else fprintf(' GPU acceleration for k-Wave DISABLED.\n'); end
    params.kwave_cache_dir = fullfile(pwd, 'kwave_cache'); if ~exist(params.kwave_cache_dir, 'dir'), mkdir(params.kwave_cache_dir); fprintf('Created k-Wave cache directory: %s\n', params.kwave_cache_dir); end; fprintf(' k-Wave cache directory: %s\n', params.kwave_cache_dir); params.kwave_force_recompute = false;
end


% --- METHOD SELECTION ---
fprintf('\n--- ESM Solver Method Selection ---\n');
disp('1. Tikhonov, 2. TSVD, 3. SBL, 4. L1-TV, 5. SBL-MMV, 6. MR-NAH, 7. Bayesian Adaptive Matched-Field (BAM-H)');
method_choice = input('Enter choice (1-7) [Default 3=SBL]: ');
%%% <<< MODIFICATION END
if isempty(method_choice), method_choice = 3; end
switch method_choice
    % ... (Cases 1-5) ...
    %%% >>> MODIFICATION START: Add Case 6
    case 6, params.method = 'mr_nah';
    case 7, params.method = 'bam_h';
    %%% <<< MODIFICATION END
    otherwise
        warning('Invalid method. Defaulting to SBL.'); params.method = 'sbl';
end
fprintf(' Selected Solver Method: %s\n', params.method);
if strcmpi(params.method, 'sbl'), fprintf('   (Using improved sparse_bayesian_learning_original)\n'); end
if strcmpi(params.method, 'l1_tv'), fprintf('   (Using Split-Bregman implementation)\n'); end %%% <<< UPDATED TEXT
if strcmpi(params.method, 'sbl_mmv'), fprintf('   (Using joint Group MMV-SBL implementation)\n'); end % Add descriptionif strcmpi(params.method, 'sbl_mmv'), fprintf('   (Using joint Group MMV-SBL implementation)\n'); end % Add description
if strcmpi(params.method, 'mr_nah'), fprintf('   (Using Adaptive Manifold Regularization)\n'); end
if strcmpi(params.method, 'bam_h'), fprintf('   (Using Bayesian Adaptive Matched-Field Holography)\n'); end

%%% <<< MODIFICATION END


% --- Solver Specific Parameters ---
% Tikhonov / TSVD / SBL setup identical to previous version - omitted for brevity
% Tikhonov
params.esm_tikhonov_lambda_rel = 1e-5; if strcmpi(params.method, 'tikhonov'), lambda_in = input(sprintf('Enter Tikhonov relative lambda (e.g., 1e-5) [Default %.1e]: ', params.esm_tikhonov_lambda_rel)); if ~isempty(lambda_in) && lambda_in >= 0, params.esm_tikhonov_lambda_rel = lambda_in; end; end
% TSVD
params.esm_tsvd_k_ratio = 0.8; params.esm_tsvd_k_abs = NaN; params.esm_tsvd_alpha = 1e-8; if strcmpi(params.method, 'tsvd'), k_in = input(sprintf('Enter fraction/number of singular values (k) for TSVD (e.g., 0.8 or 50) [Default %.2f ratio]: ', params.esm_tsvd_k_ratio)); if ~isempty(k_in), if k_in > 0 && k_in < 1, params.esm_tsvd_k_ratio = k_in; params.esm_tsvd_k_abs = NaN; elseif k_in >= 1, params.esm_tsvd_k_abs = round(k_in); params.esm_tsvd_k_ratio = NaN; else, fprintf(' Invalid k input. Using default ratio.\n'); params.esm_tsvd_k_abs = NaN; end; else, params.esm_tsvd_k_abs = NaN; end; reg_in = input(sprintf('Enter TSVD internal regularization alpha (e.g., 1e-8) [Default %.1e]: ', params.esm_tsvd_alpha)); if ~isempty(reg_in) && reg_in >= 0, params.esm_tsvd_alpha = reg_in; end; end
% SBL (original improved)
params.esm_sbl_max_iter = 5000; params.esm_sbl_tolerance_alpha = 1e-5; params.esm_sbl_track = true; params.esm_sbl_plot = true; params.sbl_stop_criterion = 'alpha'; params.sbl_stop_tolerance_z = 1e-4; params.sbl_stop_tolerance_res = 1e-4; params.sbl_stop_patience = 20;
if strcmpi(params.method, 'sbl'), iter_in = input(sprintf('Enter SBL Max Iterations [Default %d]: ', params.esm_sbl_max_iter)); if ~isempty(iter_in) && iter_in > 0, params.esm_sbl_max_iter = round(iter_in); end; tol_alpha_in = input(sprintf('Enter SBL Alpha Tolerance (e.g., 1e-5) [Default %.1e]: ', params.esm_sbl_tolerance_alpha)); if ~isempty(tol_alpha_in) && tol_alpha_in > 0, params.esm_sbl_tolerance_alpha = tol_alpha_in; end; fprintf('Select SBL Stopping Criterion:\n 1. Alpha [D]\n 2. Solution\n 3. Residual\n 4. Active Set\n 5. Combined\n'); stop_choice = input('Enter choice (1-5) [Default 1]: '); if isempty(stop_choice), stop_choice = 1; end; switch stop_choice, case 1, params.sbl_stop_criterion = 'alpha'; case 2, params.sbl_stop_criterion = 'solution'; tol_z_in = input(sprintf('  Sol Tol [Def %.1e]: ', params.sbl_stop_tolerance_z)); if ~isempty(tol_z_in) && tol_z_in > 0, params.sbl_stop_tolerance_z = tol_z_in; end; case 3, params.sbl_stop_criterion = 'residual'; tol_res_in = input(sprintf('  Res Tol [Def %.1e]: ', params.sbl_stop_tolerance_res)); if ~isempty(tol_res_in) && tol_res_in > 0, params.sbl_stop_tolerance_res = tol_res_in; end; case 4, params.sbl_stop_criterion = 'active_set'; case 5, params.sbl_stop_criterion = 'combined'; tol_z_in = input(sprintf('  Sol Tol [Def %.1e]: ', params.sbl_stop_tolerance_z)); if ~isempty(tol_z_in) && tol_z_in > 0, params.sbl_stop_tolerance_z = tol_z_in; end; tol_res_in = input(sprintf('  Res Tol [Def %.1e]: ', params.sbl_stop_tolerance_res)); if ~isempty(tol_res_in) && tol_res_in > 0, params.sbl_stop_tolerance_res = tol_res_in; end; otherwise, warning('Invalid stop choice. Defaulting to Alpha.'); params.sbl_stop_criterion = 'alpha'; end; patience_in = input(sprintf('Enter Stopping Patience (iters) [Default %d]: ', params.sbl_stop_patience)); if ~isempty(patience_in) && patience_in > 0, params.sbl_stop_patience = round(patience_in); end; track_in = input(sprintf('Track SBL history? (Y/n)'),'s'); if ~isempty(track_in) && lower(track_in(1))=='n', params.esm_sbl_track = false; end; plot_in = input(sprintf('Plot SBL convergence? (Y/n)'),'s'); if ~isempty(plot_in) && lower(plot_in(1))=='n', params.esm_sbl_plot = false; end; end

% Manifold Regularization (MR-NAH)
params.mr_lambda = 1e-3;      % Overall regularization strength
params.mr_sigma_x_factor = 2; % Spatial kernel width factor (relative to dx)
params.mr_max_iter = 30;      % Iterations for adaptive graph learning
params.mr_tol = 1e-4;         % Convergence tolerance

if strcmpi(params.method, 'mr_nah')
       
    lambda_in = input(sprintf('Enter MR-NAH Lambda (regularization strength) [Default %.1e]: ', params.mr_lambda));
    if ~isempty(lambda_in) && lambda_in >= 0, params.mr_lambda = lambda_in; end
    
    sigma_x_in = input(sprintf('Enter MR-NAH Sigma_X factor (spatial kernel width relative to dx) [Default %.1f]: ', params.mr_sigma_x_factor));
    if ~isempty(sigma_x_in) && sigma_x_in > 0, params.mr_sigma_x_factor = sigma_x_in; end
    
    iter_in = input(sprintf('Enter MR-NAH Max Adaptive Iterations [Default %d]: ', params.mr_max_iter));
    if ~isempty(iter_in) && iter_in > 0, params.mr_max_iter = round(iter_in); end
    
    tol_in = input(sprintf('Enter MR-NAH Tolerance [Default %.1e]: ', params.mr_tol));
    if ~isempty(tol_in) && tol_in > 0, params.mr_tol = tol_in; end
end

% L1-TV (Split-Bregman) %%% <<< UPDATED PARAMS
params.esm_l1_tv_max_iter = 300; % Split-Bregman default
params.esm_l1_tv_lambda_l1 = 0.001;
params.esm_l1_tv_lambda_tv = 0.001;
params.esm_l1_tv_tolerance = 1e-4; % Convergence tolerance for Split-Bregman
if strcmpi(params.method, 'l1_tv') % Ask only if selected
     l1_in = input(sprintf('Enter L1-TV Lambda_L1 (sparsity) [Default %.3f]: ', params.esm_l1_tv_lambda_l1)); if ~isempty(l1_in) && l1_in >= 0, params.esm_l1_tv_lambda_l1 = l1_in; end
     tv_in = input(sprintf('Enter L1-TV Lambda_TV (smoothness) [Default %.3f]: ', params.esm_l1_tv_lambda_tv)); if ~isempty(tv_in) && tv_in >= 0, params.esm_l1_tv_lambda_tv = tv_in; end
      iter_in = input(sprintf('Enter L1-TV Max Iterations [Default %d]: ', params.esm_l1_tv_max_iter)); if ~isempty(iter_in) && iter_in > 0, params.esm_l1_tv_max_iter = round(iter_in); end
      tol_in = input(sprintf('Enter L1-TV Tolerance [Default %.1e]: ', params.esm_l1_tv_tolerance)); if ~isempty(tol_in) && tol_in > 0, params.esm_l1_tv_tolerance = tol_in; end
end

%%% >>> MODIFICATION START: Add BAM-H Parameters
% Bayesian Adaptive Matched-Field Holography (BAM-H)
params.bamh_N_mc_samples = 100; % Number of Monte Carlo samples for the medium
params.bamh_sbl_max_iter = 500; % Iterations for the internal SBL solver

if strcmpi(params.method, 'bam_h')
    if strcmpi(params.medium_type, 'air_only')
        error('BAM-H is designed for uncertain media (e.g., Bark). It provides no advantage for Air Only scenarios.');
    end
    if params.use_kwave_propagator
        % BAM-H requires many (N_mc) forward model evaluations.
        warning('BAM-H with k-Wave will be extremely slow due to Monte Carlo sampling. TMM is strongly recommended.');
    end
    
    samples_in = input(sprintf('Enter BAM-H Number of Monte Carlo Samples [Default %d]: ', params.bamh_N_mc_samples));
    if ~isempty(samples_in) && samples_in > 0, params.bamh_N_mc_samples = round(samples_in); end
    
    iter_in = input(sprintf('Enter BAM-H Internal SBL Max Iterations [Default %d]: ', params.bamh_sbl_max_iter));
    if ~isempty(iter_in) && iter_in > 0, params.bamh_sbl_max_iter = round(iter_in); end
end

% --- GA Toggle ---
% (Identical to previous version - omitted for brevity)
ga_opt_choice = input('Enable Material Property Optimization using GA? (y/N): ','s'); if ~isempty(ga_opt_choice) && lower(ga_opt_choice(1)) == 'y', if ~can_run_ga, warning('Cannot enable GA: Global Optimization Toolbox license missing.'); params.optimize_material_properties = false; else params.optimize_material_properties = true; fprintf(' GA optimization ENABLED.\n'); end; else params.optimize_material_properties = false; fprintf(' GA optimization DISABLED.\n'); end


% --- Other Settings ---
% (Identical to previous version - omitted for brevity)
params.use_adaptive_threshold = true; params.detection_threshold = 0.3; params.spec_analysis_f1 = 500; params.spec_analysis_f2 = 10000; params.scaleFactor = 100; params.fft_n_points = [];


% --- Print Summary ---
fprintf('\n--- Setup Summary ---\n');
prop_method_summary = iif(params.use_kwave_propagator, 'k-Wave', 'TMM Analytical'); %%% <<< UPDATED
fprintf(' Propagator Method: %s\n', prop_method_summary);
fprintf(' Scenario Desc: %s\n', params.scenario_description);
fprintf(' Medium Config: %s\n', params.medium_type);
if ~strcmpi(params.medium_type, 'air_only'), fprintf(' Layer Material: %s\n', params.layer_material); fprintf(' Layer Thickness: %.4f m (%.2f cm)\n', params.layer_thickness, params.layer_thickness*100); end
fprintf(' Mic Array (z=0) to Front Surface Distance: %.4f m\n', params.dist_mic_to_front_surface);
fprintf(' ESM Solver Method: %s\n', params.method);
fprintf('  -> ESM Delta_Z Factor (rel to dx): %.2f\n', params.esm_delta_z_factor);
if params.use_kwave_propagator, fprintf('  -> k-Wave: ppw=%.2f, CFL=%.2f, tEndFactor=%.2f, PML=%d\n', params.kwave_ppw, params.kwave_CFL, params.kwave_t_end_factor, params.kwave_pml_size); gpu_status_str = iif(params.kwave_gpu_available_and_selected, 'ENABLED (GPU Available)', iif(params.kwave_use_gpu, 'Requested (GPU Unavailable/Toolbox Missing)', 'DISABLED')); fprintf('  -> k-Wave GPU Acceleration: %s\n', gpu_status_str); end
fprintf(' Material Property Optimization (GA): %s\n', iif(params.optimize_material_properties, 'ENABLED', 'DISABLED'));
% --- Print Summary --- %%% <<< ADD TO SUMMARY >>>
fprintf('\n--- Setup Summary ---\n');
% ... (previous summary lines) ...
fprintf(' Multi-Frequency Processing: %s\n', iif(params.use_multifreq, sprintf('ENABLED (%s, %s fusion, ResThresh=%.3f)', params.multifreq_bin_selection, params.multifreq_fusion_method, params.multifreq_residual_threshold), 'DISABLED')); %%% <<< UPDATED
fprintf(' Minimum Frequency for Analysis: %.1f Hz\n', params.min_freq_for_analysis);


%% 2. Load Experimental Data
% (Identical to previous version - omitted for brevity)
fprintf('\n--- Loading Experimental Data ---\n'); 
storageLocation = uigetdir('C:\', 'Select the RecordingGroup Folder'); 
if storageLocation == 0, error('No folder selected.'); end 
fprintf(' Loading data from: %s\n', storageLocation);
try read_duration = Inf; read_start_time = 0; 
    fprintf(' Reading %s seconds of data starting at %.2f s.\n', num2str(read_duration), read_start_time);
    [data_raw, sampleRate, nrOfSamples, nrOfChannels, microphonePositions] = readRecordingGroup(storageLocation);
    fprintf(' Initial load complete. Size: %d x %d, Rate: %.2f Hz, Duration: %.2f s, Channels: %d\n', size(data_raw,1), size(data_raw,2), sampleRate, nrOfSamples/sampleRate, nrOfChannels);
    params.numMics = nrOfChannels; params.mic_coords_raw = microphonePositions; 
    fprintf(' Raw range: [%.3f, %.3f]\n', min(data_raw(:)), max(data_raw(:))); micSens_in = input('Enter Microphone Sensitivity (dBV/Pa, e.g., -26): '); 
    if isempty(micSens_in), error('Microphone sensitivity required.'); end
    params.microphoneSensitivity = micSens_in; 
    fprintf(' Converting data to Pascal (Sensitivity %.2f dBV/Pa)...\n', params.microphoneSensitivity); 
    data_pascal = convertRawToPascal(data_raw, params.microphoneSensitivity);
    if any(isnan(data_pascal(:))) || any(isinf(data_pascal(:)))
        warning('NaN/Inf in Pascal data!'); data_pascal(isnan(data_pascal))=0; 
        data_pascal(isinf(data_pascal))=0;
    end
    data = data_pascal; clear data_raw data_pascal; fprintf(' Data converted to Pascal. Range: [%.3e, %.3e]\n', min(data(:)), max(data(:))); 
    fprintf('\n--- MICROPHONE POSITION VERIFICATION ---\n'); fprintf(' Min Coords: X=%.4f, Y=%.4f, Z=%.4f\n', min(params.mic_coords_raw(:,1)), min(params.mic_coords_raw(:,2)), min(params.mic_coords_raw(:,3))); fprintf(' Max Coords: X=%.4f, Y=%.4f, Z=%.4f\n', max(params.mic_coords_raw(:,1)), max(params.mic_coords_raw(:,2)), max(params.mic_coords_raw(:,3))); params.mean_mic_z = mean(params.mic_coords_raw(:,3)); fprintf(' Mean Z-coord: %.4f m (This defines z=0)\n', params.mean_mic_z); disp('<<< REVIEW COORDINATES AND ORDER. Press Enter >>>'); pause; fprintf('------------------------------------------\n');
catch ME_load, fprintf('\n--- ERROR Loading Data ---\n'); fprintf(' Msg: %s\nFile: %s, Line: %d\n', ME_load.message, ME_load.stack(1).name, ME_load.stack(1).line); rethrow(ME_load); 
end


%% 3. Define Geometry
% (Identical to previous version - omitted for brevity)
fprintf('\n--- Defining Geometry for NAH --- \n'); params.arraySide = round(sqrt(params.numMics));
if params.arraySide^2 ~= params.numMics, warning('Mic count %d not perfect square. Grid %dx%d.', params.numMics, params.arraySide, params.arraySide); end;
params.N = params.arraySide;
try if params.N > 1, diffs_x = []; diffs_y = []; if params.numMics >= 2, dx_x = abs(params.mic_coords_raw(2,1) - params.mic_coords_raw(1,1)); else dx_x=NaN;end; if params.numMics >= params.N + 1, dx_y = abs(params.mic_coords_raw(params.N + 1, 2) - params.mic_coords_raw(1, 2)); else dx_y=NaN; end; for r = 1:params.arraySide, for c = 1:params.arraySide-1, idx1 = (r-1)*params.arraySide + c; idx2 = idx1 + 1; if idx1<=params.numMics && idx2<=params.numMics, diffs_x = [diffs_x; abs(params.mic_coords_raw(idx2,1) - params.mic_coords_raw(idx1,1))]; end; end; end; for c = 1:params.arraySide, for r = 1:params.arraySide-1, idx1 = (r-1)*params.arraySide + c; idx2 = idx1 + params.arraySide; if idx1<=params.numMics && idx2<=params.numMics, diffs_y = [diffs_y; abs(params.mic_coords_raw(idx2,2) - params.mic_coords_raw(idx1,2))]; end; end; end; dx_est_x = median(diffs_x(diffs_x > 1e-4)); dx_est_y = median(diffs_y(diffs_y > 1e-4)); valid_ests = [dx_x, dx_y, dx_est_x, dx_est_y]; valid_ests = valid_ests(~isnan(valid_ests) & valid_ests > 1e-4); if ~isempty(valid_ests), params.dx = mean(valid_ests); else, params.dx = mean([max(params.mic_coords_raw(:,1))-min(params.mic_coords_raw(:,1)), max(params.mic_coords_raw(:,2))-min(params.mic_coords_raw(:,2))]) / max(1,(params.N-1)); end; else, params.dx = 0.01; end; if isnan(params.dx) || params.dx <= 1e-6, warning('dx estimation failed. Using 0.01m'); params.dx = 0.01; end; catch ME_geom, fprintf('Error during dx estimation: %s. Using 0.01m.\n', ME_geom.message); params.dx = 0.01; end; fprintf(' Estimated Grid Spacing params.dx = %.5f m\n', params.dx);
if strcmpi(params.method, 'mr_nah')
    % Ensure params.dx exists and is valid
    if ~isfield(params, 'dx') || isnan(params.dx) || params.dx <= 1e-6
        warning('MR-NAH: dx estimation seems to have failed. Using fallback dx=0.01m for spatial kernel width.');
        params.mr_sigma_x = params.mr_sigma_x_factor * 0.01; % Fallback
    else
        params.mr_sigma_x = params.mr_sigma_x_factor * params.dx;
    end
    fprintf(' MR-NAH Spatial Kernel Width (Sigma_X): %.5f m\n', params.mr_sigma_x);
end

params.meas_plane_z = params.mean_mic_z; params.layer_front_z = params.mean_mic_z - params.dist_mic_to_front_surface; params.layer_back_z = params.layer_front_z - params.layer_thickness; params.recon_plane_z = params.layer_front_z; params.esm_delta_z = params.esm_delta_z_factor * params.dx; params.esm_plane_z = params.layer_back_z - params.esm_delta_z;
fprintf(' Measurement Plane Z: %.4f m\n', params.meas_plane_z); fprintf(' Layer Front Surface Z: %.4f m\n', params.layer_front_z); fprintf(' Layer Back Surface Z: %.4f m\n', params.layer_back_z); fprintf(' Recon Plane Z: %.4f m\n', params.recon_plane_z); fprintf(' ESM Plane Z: %.4f m (Delta Z = %.4f m)\n', params.esm_plane_z, params.esm_delta_z); if params.esm_delta_z <= 0, error('ESM delta_z must be positive.'); end; if params.layer_back_z >= params.layer_front_z && params.layer_thickness > 1e-9, error('Layer geometry inconsistent (back >= front). Back=%.4f, Front=%.4f', params.layer_back_z, params.layer_front_z); end; if params.esm_plane_z >= params.layer_back_z && params.layer_thickness > 1e-9, warning('ESM plane Z >= Layer back Z (%.4f >= %.4f).', params.esm_plane_z, params.layer_back_z); end
mean_mic_x = mean(params.mic_coords_raw(:,1)); mean_mic_y = mean(params.mic_coords_raw(:,2)); fprintf(' Centering grids around Mean Mic X=%.4f, Y=%.4f\n', mean_mic_x, mean_mic_y); grid_dim = (params.N - 1) * params.dx; x_vec = linspace(-grid_dim/2, grid_dim/2, params.N) + mean_mic_x; y_vec = linspace(-grid_dim/2, grid_dim/2, params.N) + mean_mic_y; [X_grid, Y_grid] = meshgrid(x_vec, y_vec);
params.num_recon_points = params.N * params.N; params.recon_points = [X_grid(:), Y_grid(:), ones(params.num_recon_points, 1) * params.recon_plane_z]; params.num_esm_sources_init = params.N * params.N; params.esm_points = [X_grid(:), Y_grid(:), ones(params.num_esm_sources_init, 1) * params.esm_plane_z];


fprintf(' Defined Grids: %d x %d points.\n', params.N, params.N); disp('------------------------------------------');

%% 4. Spectral Analysis & Region Selection
% (Identical to previous version - omitted for brevity)
fprintf('\n--- Spectral Analysis & Region Selection ---\n'); duration = nrOfSamples / sampleRate; try [regionsData, ~, ~] = plotSpectrogramSegment(data, sampleRate, 0, duration, params.spec_analysis_f1, params.spec_analysis_f2); if isempty(regionsData), disp(' No regions selected. Processing entire file.'); regionsData = struct('t_start', 0, 't_end', duration, 'f_min', params.spec_analysis_f1, 'f_max', params.spec_analysis_f2); else, fprintf(' User selected %d region(s).\n', length(regionsData)); end; catch ME_spect, fprintf('\n ERROR during Spectrogram: %s\n Processing entire file.\n', ME_spect.message); regionsData = struct('t_start', 0, 't_end', duration, 'f_min', params.spec_analysis_f1, 'f_max', params.spec_analysis_f2); end; disp('------------------------------------------'); fprintf(' << Spectrogram region selection complete.\n');


%% 5. Process Each Selected Region (Optimized: BAM-H, Narrowband, MR-NAH)

% Determine summaries for display/logging
prop_method_summary = iif(params.use_kwave_propagator, 'k-Wave', 'TMM');
mf_status = iif(params.use_multifreq, 'Multi-Freq', 'Single-Freq');

% Determine the solver name to be used/displayed
solver_display_name = upper(params.method);
use_group_sbl = false; % Initialize flag

% Check for Group SBL (MMV) configuration
if strcmpi(params.method, 'sbl_mmv')
    if params.use_multifreq
        solver_display_name = 'GroupSBL';
        use_group_sbl = true;
    else
        warning('SBL-MMV selected, but Multi-Frequency Processing is OFF. Running standard SBL instead.');
        params.method = 'sbl'; % Revert to standard SBL
        solver_display_name = 'SBL';
        use_group_sbl = false;
    end
end

% Handle BAM-H display name and status
if strcmpi(params.method, 'bam_h')
    solver_display_name = 'BAM-H';
    mf_status = 'Single-Freq (BAM-H)'; % BAM-H focuses on dominant frequency
end

fprintf('\n--- Processing %d Region(s) using ESM (%s solver, %s config, Prop: %s, %s) ---\n', ...
    length(regionsData), solver_display_name, params.medium_type, prop_method_summary, mf_status);

results = cell(length(regionsData), 1);

% --- Define Layer Info Struct ---
% This defines the baseline configuration. 
layer_info = struct();
layer_info.medium_type = params.medium_type;
layer_info.db = params.material_database; % Contains base properties AND uncertainty ranges
layer_info.layer_material_name = params.layer_material;

if ~strcmpi(params.medium_type, 'air_only')
    layer_info.material_air_front_name = 'air'; 
    layer_info.material_air_back_name = 'air';
    layer_info.z_interface_front = params.layer_front_z; 
    layer_info.z_interface_back = params.layer_back_z;
    layer_info.thickness = params.layer_thickness;
    
    % Print initial properties (the mean/default value)
    if isfield(params.material_database, params.layer_material)
        mat_layer = params.material_database.(params.layer_material);
        fprintf(' Initial Layer Properties (%s): c=%.2f, rho=%.2f, alpha=%.2f dB/m @ %.2f kHz, alpha_power=%.2f\n', ...
                params.layer_material, mat_layer.c, mat_layer.rho, mat_layer.alpha_dB_m, mat_layer.alpha_freq_Hz/1000, mat_layer.alpha_power);
        
        % Display uncertainty ranges if BAM-H is active
        if strcmpi(params.method, 'bam_h')
            if isfield(mat_layer, 'c_range') && isfield(mat_layer, 'rho_range')
                 fprintf('   BAM-H Uncertainty Ranges: c=[%.1f, %.1f] m/s, rho=[%.1f, %.1f] kg/m^3\n', ...
                 mat_layer.c_range(1), mat_layer.c_range(2), mat_layer.rho_range(1), mat_layer.rho_range(2));
            else
                 error('BAM-H selected, but uncertainty ranges (c_range, rho_range) are missing for material: %s', params.layer_material);
            end
        end
    else
         error('Material "%s" selected but not found in the material database.', params.layer_material);
    end
else
    layer_info.material_air_front_name = 'air'; 
    layer_info.material_air_back_name = 'air';
    layer_info.z_interface_front = -Inf; 
    layer_info.z_interface_back = -Inf; 
    layer_info.thickness = 0;
end
% --- ---

% =======================================================================
% --- START REGION LOOP ---
% =======================================================================
for rIdx = 1:length(regionsData)
    region = regionsData(rIdx);
    fprintf('\n=============== Processing Region %d ===============\n', rIdx);
    fprintf('Time [%.3f - %.3f s], Freq [%.2f - %.2f Hz]\n', region.t_start, region.t_end, region.f_min, region.f_max);

    % 5a. Extract Time Slice & Window
    idxStart = max(1, round(region.t_start * sampleRate)); 
    idxEnd = min(nrOfSamples, round(region.t_end * sampleRate)); 
    if idxStart >= idxEnd, fprintf(' Skip: Invalid time slice.\n'); results{rIdx}=[]; continue; end
    
    % Basic data integrity checks
    if idxEnd > size(data, 1), error('idxEnd (%d) exceeds data samples (dim 1 = %d).', idxEnd, size(data,1)); end; 
    
    segmentData = data(idxStart:idxEnd, :); 
    segLen = size(segmentData, 1); 
    fprintf(' Extracted segment: %d samples.\n', segLen); 
    if segLen < 64, fprintf(' Skip: Segment too short.\n'); results{rIdx}=[]; continue; end;
    
    % Apply windowing
    segmentDataWindowed = segmentData .* hann(segLen);

    % 5b. FFT
    N_fft = 2^nextpow2(segLen); fprintf(' FFT (N=%d).\n', N_fft);
    fftSegmentData = fft(segmentDataWindowed, N_fft, 1);
    freqs = sampleRate * (0:floor(N_fft/2)) / N_fft;

    % 5c. Select Frequency Bins to Process
    fprintf(' Selecting frequency bins to process...\n');
    freqMask = (freqs >= region.f_min) & (freqs <= region.f_max) & (freqs >= params.min_freq_for_analysis);
    regionFreqIndices = find(freqMask); regionFreqs = freqs(freqMask);
    
    if isempty(regionFreqs), fprintf(' Skip: No valid freqs in region.\n'); results{rIdx}=[]; continue; end
    
    % Calculate power and find peak frequency
    avgPowerPerBin = mean(abs(fftSegmentData(regionFreqIndices, :)).^2, 2);
    if isempty(avgPowerPerBin) || all(avgPowerPerBin < eps), fprintf(' Skip: Zero power in region.\n'); results{rIdx}=[]; continue; end;
    
    [peakPower, peakIdxRel] = max(avgPowerPerBin);
    peakFreq = regionFreqs(peakIdxRel);
    peak_bin_index_abs = regionFreqIndices(peakIdxRel);

    % Store peak p_meas for reference/visualization
    p_meas_vec_peak = fftSegmentData(peak_bin_index_abs, :).'; 
    norm_p_meas_peak = norm(p_meas_vec_peak);
     if isempty(p_meas_vec_peak) || norm_p_meas_peak < eps
        warning('Measured p_meas_vec for peak freq %.2f Hz is empty or near zero. Skipping region.', peakFreq);
        results{rIdx}=[]; continue;
    end
    fprintf(' Step 1: Peak Freq p_meas (Size %dx%d, Norm=%.3e) at %.2f Hz.\n', size(p_meas_vec_peak,1), size(p_meas_vec_peak,2), norm_p_meas_peak, peakFreq);

    % --- Select frequencies indices based on strategy ---
    selectedFreqIndicesAbs = [];
    
    % Check if BAM-H is active first, as it overrides other multi-freq settings
    if strcmpi(params.method, 'bam_h')
        selectedFreqIndicesAbs = peak_bin_index_abs; 
        selectedFreqs = peakFreq;
        fprintf(' --> BAM-H Mode: Focusing on Dominant Freq: %.2f Hz.\n', selectedFreqs);
    
    elseif params.use_multifreq || use_group_sbl 
        % Standard Multi-Frequency or Group SBL selection
        switch params.multifreq_bin_selection
            case 'top_n'
                [~, sortedPowerIdxRel] = sort(avgPowerPerBin, 'descend'); 
                numToSelect = min(params.num_freq_bins, length(sortedPowerIdxRel)); 
                selectedIdxRel = sortedPowerIdxRel(1:numToSelect); 
                selectedFreqIndicesAbs = regionFreqIndices(selectedIdxRel);
            case 'threshold'
                powerThreshold = peakPower * 10^(params.multifreq_power_thresh_db / 10); 
                selectedIdxRel = find(avgPowerPerBin >= powerThreshold); 
                if isempty(selectedIdxRel)
                    warning('No bins above power threshold %.1f dB. Using only peak frequency.', params.multifreq_power_thresh_db); 
                    selectedIdxRel = peakIdxRel; 
                end
                selectedFreqIndicesAbs = regionFreqIndices(selectedIdxRel);
        end
        selectedFreqs = freqs(selectedFreqIndicesAbs);
        fprintf(' --> Multi-Freq Enabled: Selected %d bins using %s. Freqs: [%.1f ... %.1f] Hz (Peak: %.1f Hz).\n', length(selectedFreqs), params.multifreq_bin_selection, min(selectedFreqs), max(selectedFreqs), peakFreq);
        
        % Ensure peak frequency is included
        if ~ismember(peak_bin_index_abs, selectedFreqIndicesAbs) && ~isempty(selectedFreqIndicesAbs)
             fprintf('    Peak frequency bin %d not initially selected, adding it.\n', peak_bin_index_abs);
             selectedFreqIndicesAbs = unique([peak_bin_index_abs; selectedFreqIndicesAbs(:)]);
             selectedFreqs = freqs(selectedFreqIndicesAbs);
             fprintf('    Updated Selected Freqs: [%.1f ... %.1f] Hz (%d bins)\n', min(selectedFreqs), max(selectedFreqs), length(selectedFreqs));
        end

    % Single Frequency Mode (Standard Solvers)
    else 
        selectedFreqIndicesAbs = peak_bin_index_abs; selectedFreqs = peakFreq;
        fprintf(' --> Single-Freq Mode: Dominant Freq: %.2f Hz (Bin Index: %d)\n', selectedFreqs, selectedFreqIndicesAbs);
    end
    
    if isempty(selectedFreqIndicesAbs), fprintf(' Skip: No frequency bins selected for processing.\n'); results{rIdx}=[]; continue; end
    num_freq_to_process = length(selectedFreqIndicesAbs);


    % --- OPTIONAL: GA Optimization ---
    ga_active = false; material_to_optimize = params.layer_material; 
    is_optimizable_material = ~strcmpi(material_to_optimize, 'air');
    % Initialize default opt status
    recon_info = struct('opt_status', sprintf('Not Optimized (%s)', material_to_optimize)); 
    
    % GA is skipped if BAM-H is used, as BAM-H performs its own optimization.
    if is_optimizable_material && params.optimize_material_properties && ~strcmpi(params.method, 'bam_h')
        % Placeholder for GA Optimization Block
        fprintf('\n--- Skipping GA Optimization (Placeholder - Implement GA if needed) ---\n');
        % If implemented, GA would update: params, layer_info, recon_info
        % ga_active = true; 
    else
         fprintf('\n--- Skipping GA Optimization (or using BAM-H optimization) ---\n');
    end
    % --- END OPTIMIZATION BLOCK

    % --- Use potentially updated parameters ---
    current_esm_points = params.esm_points; % May have been updated by GA
    fprintf(' Final ESM Plane Z for reconstruction: %.4f m\n', params.esm_plane_z);

    % =======================================================================
    % --- 5d/e/f: Data Collection and Solver Stage ---
    % =======================================================================

    %%% >>> START BAM-H EXECUTION BLOCK <<<
    % BAM-H handles its own workflow and bypasses the standard pipeline.
    if strcmpi(params.method, 'bam_h')
        fprintf('\n--- Running Bayesian Adaptive Matched-Field Holography (BAM-H) ---\n');
        
        % Extract Pressure Data (We know num_freq_to_process = 1)
        current_bin_index_abs = selectedFreqIndicesAbs(1);
        P_meas_vec = fftSegmentData(current_bin_index_abs, :).';
        current_freq = selectedFreqs(1);
        current_omega = 2 * pi * current_freq;

        % Run the BAM-H solver
        tic_bamh = tic;
        try
            % We pass the necessary data structures to the solver
            [Q_esm_bamh, bamh_info] = BAM_H_Solver(P_meas_vec, current_omega, params, layer_info, params.mic_coords_raw, current_esm_points);
            solve_time = toc(tic_bamh);
            fprintf('   BAM-H finished in %.2f s. Status: %s\n', solve_time, bamh_info.message);

            % --- Post-processing and Storing Results (BAM-H Specific) ---
            % Calculate reconstruction using the optimized H_r provided by the solver
            H_r_opt = bamh_info.H_r_optimized;
            P_recon_vec = H_r_opt * Q_esm_bamh;
            
            % Create normalized map
            detection_map = abs(reshape(P_recon_vec, params.N, params.N));
            max_val = max(detection_map(:));
            if max_val > eps, detection_map_fused_norm = detection_map / max_val; else, detection_map_fused_norm = zeros(params.N, params.N); end

            % Apply basic post-processing (smoothing and thresholding) for visualization consistency
            detection_map_smooth = detection_map_fused_norm;
            try 
                sigma_smooth = 0.5; 
                detection_map_smooth = imgaussfilt(detection_map_fused_norm, sigma_smooth); 
            catch, end
            detection_map_smooth(detection_map_smooth<0)=0; 
            
            % Use adaptive thresholding if enabled
            final_threshold = params.detection_threshold;
            beetle_detected = detection_map_smooth > final_threshold;

            if params.use_adaptive_threshold && max(detection_map_smooth(:)) > min(detection_map_smooth(:)) + eps
                try
                    [temp_mask, temp_threshold] = adaptive_threshold_detection(detection_map_smooth);
                    if isfinite(temp_threshold)
                        final_threshold = temp_threshold;
                        beetle_detected = temp_mask;
                    end
                catch, end
            end

            % Determine best residual (from BAM-H info)
            best_rel_res = bamh_info.relative_residual;
            
            % Determine H condition at the optimized parameters (if calculated inside BAM-H)
            final_peak_H_condition = NaN; 
            if isfield(bamh_info, 'H_esm_optimized_cond')
                final_peak_H_condition = bamh_info.H_esm_optimized_cond;
            end

            % Store in the final results structure format
            regionResult = struct(...
                'ID', rIdx, 'tStart', region.t_start, 'tEnd', region.t_end, ...
                'ProcessedFrequencies', current_freq, ... 
                'PeakFrequency', current_freq, ...
                'Method', params.method, 'SolverUsed', solver_display_name, ...
                'PropagatorMethod', prop_method_summary, 'MultiFreqStatus', mf_status, 'MultiFreqFusionMethod', 'N/A (BAM-H)', ...
                'MediumType', params.medium_type, 'LayerMaterial', params.layer_material, 'LayerThickness', params.layer_thickness, 'DistMicToFrontSurface', params.dist_mic_to_front_surface, ...
                'ESM_DeltaZ_Factor', params.esm_delta_z_factor, 'ESM_DeltaZ_Absolute', params.esm_delta_z, ...
                'H_MatrixCondition', final_peak_H_condition, ...
                'MeasuredPressureVec', P_meas_vec, ...
                'IndividualFreqInfo', {{struct('frequency', current_freq, 'relative_residual', best_rel_res)}}, ...
                'FusionWeights', 1.0, ...
                'DetectionMapFusedNorm', detection_map_fused_norm, ...
                'DetectionMapSmooth', detection_map_smooth, ... 
                'DetectionThreshold', final_threshold, ...
                'DetectedMask', beetle_detected, ...
                'BestRelativeResidual', best_rel_res, ...
                'ReconstructionInfo', bamh_info); % Store BAM-H specific info (optimized parameters)

            % Add grid info if available (from Section 3)
            if exist('X_grid', 'var'), regionResult.X_grid = X_grid; end
            if exist('Y_grid', 'var'), regionResult.Y_grid = Y_grid; end
            
            results{rIdx} = regionResult;
            
        catch ME_bamh
            warning('Region %d: BAM-H failed: %s.', rIdx, ME_bamh.message);
            fprintf('Error details: %s\n', ME_bamh.getReport());
            results{rIdx} = [];
        end
        
        fprintf('Finished processing Region %d (BAM-H).\n', rIdx);
        fprintf('=================================================\n');
        continue; % Skip the standard processing pipeline
    end
    %%% <<< END BAM-H Block

    % --- Standard Processing Pipeline (Tikhonov, SBL, MR-NAH, MMV, etc.) ---

    % --- Initialize Storage ---
    H_esm_cell = cell(num_freq_to_process, 1);
    H_r_cell = cell(num_freq_to_process, 1);
    P_cell = cell(num_freq_to_process, 1);
    per_freq_recon_info = cell(num_freq_to_process, 1); % Store individual results
    freq_metadata = struct('frequency', [], 'bin_index', [], 'H_condition', [], 'valid_source_indices', [], 'norm_p_meas', []);
    freq_metadata = repmat(freq_metadata, num_freq_to_process, 1);
    valid_freq_mask = false(num_freq_to_process, 1); % Track success of H prep

    params.kwave_force_recompute = false; % Allow caching

    %%% >>> MODIFICATION: Initialize Narrowband Tracking Variables
    % Structure array to store H matrices calculated in this region for reuse
    H_reuse_cache = struct('freq', {}, 'H_esm', {}, 'H_r', {}, 'valid_indices', {}, 'N_valid', {}, 'delete_indices', {}, 'H_condition', {});
    
    % Check if narrowband optimization is active for this run
    use_narrowband_optimization = params.use_multifreq && isfield(params, 'use_narrowband_approx') && params.use_narrowband_approx;
    %%% <<< END MODIFICATION

    fprintf('--- Preparing Data & Propagators for %d Frequencies ---\n', num_freq_to_process);
    
    % =======================================================================
    % --- START FREQUENCY PREPARATION LOOP (Optimized with Narrowband) ---
    % =======================================================================
    for freq_idx = 1:num_freq_to_process
        current_bin_index_abs = selectedFreqIndicesAbs(freq_idx);
        current_freq = freqs(current_bin_index_abs);
        current_omega = 2 * pi * current_freq;
        fprintf('   Freq %.2f Hz (%d/%d): ', current_freq, freq_idx, num_freq_to_process);

        % Store metadata and Extract pressure
        freq_metadata(freq_idx).frequency = current_freq;
        freq_metadata(freq_idx).bin_index = current_bin_index_abs;
        p_meas_vec_freq = fftSegmentData(current_bin_index_abs, :).';
        norm_p_meas_freq = norm(p_meas_vec_freq);
        freq_metadata(freq_idx).norm_p_meas = norm_p_meas_freq;
        
        if norm_p_meas_freq < eps
             fprintf('Skipping (Zero p_meas).\n');
             per_freq_recon_info{freq_idx} = struct('message','Zero p_meas','relative_residual',NaN);
             continue;
        end
        P_cell{freq_idx} = p_meas_vec_freq;
        fprintf('p_meas OK. ');

        % Initialize H variables for this iteration
        H_esm_curr = []; N_esm_valid_curr = 0; deleteIndexesVirt_esm_curr = []; H_condition_curr = NaN; valid_source_indices_curr = [];
        H_r_curr = []; 
        
        %%% >>> MODIFICATION: Narrowband Approximation Logic (Multi-Entry Cache)
        use_narrowband_cache = false;
        if use_narrowband_optimization && ~isempty(H_reuse_cache)
            for cache_idx = 1:length(H_reuse_cache)
                cached_freq = H_reuse_cache(cache_idx).freq;
                % Check deviation threshold
                allowed_deviation = cached_freq * (params.narrowband_thresh_percent / 100);
                
                if abs(current_freq - cached_freq) <= allowed_deviation
                    fprintf('[Narrowband Hit: Using H from %.2f Hz] ', cached_freq);
                    H_esm_curr = H_reuse_cache(cache_idx).H_esm;
                    H_r_curr = H_reuse_cache(cache_idx).H_r;
                    valid_source_indices_curr = H_reuse_cache(cache_idx).valid_indices;
                    N_esm_valid_curr = H_reuse_cache(cache_idx).N_valid;
                    deleteIndexesVirt_esm_curr = H_reuse_cache(cache_idx).delete_indices;
                    H_condition_curr = H_reuse_cache(cache_idx).H_condition;
                    use_narrowband_cache = true;
                    break;
                end
            end
        end
        %%% <<< END MODIFICATION
        
        try
            %%% >>> MODIFICATION: Check if we need to calculate H
            if ~use_narrowband_cache
            %%% <<< END MODIFICATION

                % Calculate H_esm
                if params.use_kwave_propagator
                     %%% >>> MODIFICATION: Pass optimization flags (CFL, DataCheck)
                     kwave_params_loop = struct(...
                        'ppw', params.kwave_ppw, 'CFL', params.kwave_CFL, 't_end_factor', params.kwave_t_end_factor, ...
                        'pml_size', params.kwave_pml_size, 'use_gpu', params.kwave_use_gpu, ...
                        'kwave_gpu_available_and_selected', params.kwave_gpu_available_and_selected, ...
                        'cache_dir', params.kwave_cache_dir, 'force_recompute', params.kwave_force_recompute, ...
                        'caller_id', sprintf('H_esm_f%.1f', current_freq));
                        %'disable_datacheck', params.kwave_disable_datacheck, ... % Pass DataCheck flag
                     %%% <<< END MODIFICATION
                     
                     [H_data_kw, cache_hit_kw] = compute_H_kwave(params.mic_coords_raw, current_esm_points, current_omega, layer_info, kwave_params_loop);
                     
                     if ~isempty(H_data_kw) && isfield(H_data_kw,'H') && ~isempty(H_data_kw.H)
                        H_esm_curr = H_data_kw.H; 
                        deleteIndexesVirt_esm_curr = H_data_kw.deleteIndexesSrc; 
                        N_esm_valid_curr = H_data_kw.N_src_valid;
                     else, error('k-Wave H_esm empty'); end
                
                else % TMM Analytical
                     [G_esm_cell, deleteIdxTMM, N_validTMM] = Green_matrix_multilayer_TMM(params.mic_coords_raw, current_esm_points, current_omega, layer_info);
                     if ~isempty(G_esm_cell) && ~isempty(G_esm_cell{1})
                         H_esm_curr = G_esm_cell{1}; 
                         deleteIndexesVirt_esm_curr = deleteIdxTMM; 
                         N_esm_valid_curr = N_validTMM;
                     else, error('TMM H_esm empty'); end
                end
                
                % Validate H_esm
                if isempty(H_esm_curr) || N_esm_valid_curr == 0, error('H_esm empty/zero valid sources.'); end
                if any(~isfinite(H_esm_curr(:))), error('H_esm contains NaN/Inf.'); end

                % Determine valid source indices
                original_indices = 1:size(current_esm_points,1);
                valid_source_indices_curr = setdiff(original_indices, deleteIndexesVirt_esm_curr);
                
                % Calculate H_r (using the VALID subset of ESM points)
                if params.use_kwave_propagator
                      %%% >>> MODIFICATION: Pass optimization flags
                      kwave_params_loop_r = kwave_params_loop; % Reuse params structure
                      kwave_params_loop_r.caller_id = sprintf('H_r_f%.1f', current_freq);
                      %%% <<< END MODIFICATION
                      
                      % Compute H from VALID esm sources to recon points
                      [H_data_r, ~] = compute_H_kwave(params.recon_points, current_esm_points(valid_source_indices_curr,:), current_omega, layer_info, kwave_params_loop_r);
                       
                      if ~isempty(H_data_r) && isfield(H_data_r,'H') && ~isempty(H_data_r.H) && size(H_data_r.H,2) == N_esm_valid_curr
                           H_r_curr = H_data_r.H;
                      else, error('k-Wave H_r failed/empty/size mismatch'); end
                
                else % TMM Analytical for H_r
                      [G_r_cell, ~, N_r_valid_tmm] = Green_matrix_multilayer_TMM(params.recon_points, current_esm_points(valid_source_indices_curr,:), current_omega, layer_info);
                      if ~isempty(G_r_cell) && ~isempty(G_r_cell{1}) && N_r_valid_tmm == N_esm_valid_curr
                          H_r_curr = G_r_cell{1};
                      else, error('TMM H_r failed/empty/size mismatch'); end
                end

                % Validate H_r
                if isempty(H_r_curr) || any(~isfinite(H_r_curr(:))), error('H_r failed/invalid.'); end

                % Calculate condition number
                try H_condition_curr = cond(double(H_esm_curr)); catch, H_condition_curr = NaN; end

                %%% >>> MODIFICATION: Update Narrowband Cache
                if use_narrowband_optimization
                    % Store the newly calculated matrices in the cache
                    new_entry = struct('freq', current_freq, 'H_esm', H_esm_curr, 'H_r', H_r_curr, ...
                                       'valid_indices', valid_source_indices_curr, 'N_valid', N_esm_valid_curr, ...
                                       'delete_indices', deleteIndexesVirt_esm_curr, 'H_condition', H_condition_curr);
                    H_reuse_cache(end+1) = new_entry;
                end
                %%% <<< END MODIFICATION
            end % End if ~use_narrowband_cache

            % Store results (calculated or cached)
            H_esm_cell{freq_idx} = H_esm_curr;
            H_r_cell{freq_idx} = H_r_curr;
            freq_metadata(freq_idx).valid_source_indices = valid_source_indices_curr;
            freq_metadata(freq_idx).H_condition = H_condition_curr;

            fprintf('H_esm OK (Cond=%.1e). H_r OK. ', H_condition_curr);
            if abs(current_freq - peakFreq) < 1e-3, G_curr_condition = H_condition_curr; end % Store peak condition
             
            valid_freq_mask(freq_idx) = true; % Mark this frequency as fully valid
            fprintf('Success.\n');

        catch ME_H
             fprintf('FAILED H Prep (%s).\n', ME_H.message);
             per_freq_recon_info{freq_idx} = struct('message',['H Prep failed: ' ME_H.message],'relative_residual',NaN);
             % valid_freq_mask(freq_idx) remains false
        end
    end % End loop collecting H and P
    % =======================================================================
    % --- END FREQUENCY PREPARATION LOOP ---
    % =======================================================================

    % --- Check if any frequencies are valid ---
    valid_freq_indices = find(valid_freq_mask);
    if isempty(valid_freq_indices)
        warning('Region %d: No frequencies succeeded during H matrix preparation. Skipping region.', rIdx);
        results{rIdx} = []; continue;
    end
    num_valid_freqs = length(valid_freq_indices);
    fprintf('--- Data preparation complete for %d valid frequencies ---\n', num_valid_freqs);
    
    % --- Filter cell arrays to contain only valid entries ---
    H_esm_cell_valid = H_esm_cell(valid_freq_indices);
    P_cell_valid = P_cell(valid_freq_indices);
    H_r_cell_valid = H_r_cell(valid_freq_indices);
    freq_metadata_valid = freq_metadata(valid_freq_indices);

    % --- Solve for Sources (Jointly or Independently) ---
    q_esm_matrix = zeros(size(current_esm_points,1), num_valid_freqs); % N x F_valid
    p_recon_matrix = zeros(params.num_recon_points, num_valid_freqs);
    all_residuals = nan(1, num_valid_freqs);
    group_recon_info = struct();

    % =======================================================================
    % --- SOLVER STAGE ---
    % =======================================================================
    if use_group_sbl
        % --- Joint Solver (Group MMV-SBL) ---
        fprintf('--- Solving using Group MMV-SBL for %d frequencies ---\n', num_valid_freqs);
        tic_solve = tic;
        try
             % Add necessary params for group SBL
             if ~isfield(params,'sbl_update_beta'), params.sbl_update_beta = false; end
             
             [Z_estimates_valid, final_alpha, group_sbl_info] = sparse_bayesian_learning_group_mmv(H_esm_cell_valid, P_cell_valid, params.esm_sbl_max_iter, params);
             solve_time = toc(tic_solve);
             fprintf('   Group SBL finished in %.2f s. Status: %s\n', solve_time, group_sbl_info.message);
             
             if size(Z_estimates_valid, 1) ~= size(current_esm_points,1)
                 error('Group SBL output Z size mismatch with initial ESM points.');
             end
             q_esm_matrix = Z_estimates_valid;
             
             % Calculate p_recon and residuals for each frequency POST-SOLVE
             fprintf('   Calculating p_recon and residuals for Group SBL results...\n');
             for f_valid = 1:num_valid_freqs
                 idx_orig = valid_freq_indices(f_valid); % Get the original index
                 
                 q_f = q_esm_matrix(:, f_valid);
                 
                 % Store the q_esm vector
                 if idx_orig <= length(per_freq_recon_info)
                     if isempty(per_freq_recon_info{idx_orig}), per_freq_recon_info{idx_orig} = struct(); end
                      per_freq_recon_info{idx_orig}.q_esm = q_f;
                 end
                 
                 H_esm_f = H_esm_cell_valid{f_valid};
                 P_f = P_cell_valid{f_valid};
                 H_r_f = H_r_cell_valid{f_valid};
                 valid_idx_f = freq_metadata_valid(f_valid).valid_source_indices;
                 norm_p_f = freq_metadata_valid(f_valid).norm_p_meas;
                 
                 % Ensure q_f is indexed correctly before multiplication
                 if max(valid_idx_f) > size(q_f, 1)
                      warning('MMV-SBL Post: valid_idx_f exceeds size of q_f. Skipping.');
                      all_residuals(f_valid) = NaN;
                      continue;
                 end
                 q_f_valid_sources = q_f(valid_idx_f); % Select sources valid for THIS H_esm/H_r
                 
                 p_recon_matrix(:, f_valid) = H_r_f * q_f_valid_sources;
                 residual_vec = H_esm_f * q_f_valid_sources - P_f;
                 current_residual = norm(residual_vec) / norm_p_f;
                 all_residuals(f_valid) = current_residual;
                 
                 % Store individual info
                 per_freq_recon_info{idx_orig} = struct(...
                      'message', sprintf('Part of GroupSBL (Iter %d)', group_sbl_info.iters), ...
                      'relative_residual', current_residual, ...
                      'iterations', group_sbl_info.iters, ...
                      'EquivalentSources_Locations', current_esm_points(valid_idx_f,:), ...
                      'q_esm', q_f );
             end
             group_recon_info = group_sbl_info; % Store overall group info
        
        catch ME_group_solve
            warning('Region %d: Group MMV-SBL failed: %s. Cannot proceed.', rIdx, ME_group_solve.message);
            results{rIdx} = []; continue; % Skip to next region
        end

    else 
        % --- Solve Independently ---
        fprintf('--- Solving independently for %d valid frequencies using %s ---\n', num_valid_freqs, params.method);
        for f_valid = 1:num_valid_freqs
            freq_idx_orig = valid_freq_indices(f_valid); % Original index
            current_freq = freq_metadata_valid(f_valid).frequency;
            fprintf('   Solving Freq %.2f Hz (%d/%d)... ', current_freq, f_valid, num_valid_freqs);
            
            H_esm_f = H_esm_cell_valid{f_valid};
            P_f = P_cell_valid{f_valid};
            H_r_f = H_r_cell_valid{f_valid};
            valid_idx_f = freq_metadata_valid(f_valid).valid_source_indices;
            norm_p_f = freq_metadata_valid(f_valid).norm_p_meas;
            N_esm_valid_f = length(valid_idx_f);
            
            q_f_valid_sources = [];
            info_recon_f = struct('message', 'Solver Not Run', 'relative_residual', NaN, 'iterations', 0);
            tic_solve = tic;
            
             try
                 switch lower(params.method)
                     case 'tikhonov'
                         H_esm_t = H_esm_f'; HtH = H_esm_t * H_esm_f;
                         lambda = params.esm_tikhonov_lambda_rel * norm(HtH,'fro'); lambda = max(lambda, eps(class(HtH)));
                         A_tik = HtH + lambda * eye(size(HtH));
                         q_f_valid_sources = A_tik \ (H_esm_t * P_f);
                         info_recon_f.message=sprintf('Tikhonov OK (rel_lam=%.1e)', params.esm_tikhonov_lambda_rel); 
                     
                     case 'tsvd'
                         [q_f_valid_sources, info_recon_f] = tsvd_reconstruction(H_esm_f, P_f, params.esm_tsvd_k_abs, params.esm_tsvd_k_ratio, params.esm_tsvd_alpha);
                     
                     case 'sbl' % Independent SBL
                          sbl_params_loop = params;
                          sbl_params_loop.esm_sbl_track = true;
                          [q_f_valid_sources, ~, ~, ~, info_recon_f] = sparse_bayesian_learning_original(H_esm_f, P_f, params.esm_sbl_max_iter, sbl_params_loop);
                     
                     case 'l1_tv'
                          [q_f_valid_sources, info_recon_f] = l1_tv_reconstruction(H_esm_f, P_f, params.esm_l1_tv_lambda_l1, params.esm_l1_tv_lambda_tv, params.esm_l1_tv_max_iter, params.N, params.esm_l1_tv_tolerance);
                     
                     case 'mr_nah'
                          % Get the coordinates of the VALID sources for this frequency
                          current_valid_esm_coords = current_esm_points(valid_idx_f,:);
                          
                          % Pass required parameters (Optimized Initialization included in solver)
                          mr_params_loop = struct(...
                              'mr_lambda', params.mr_lambda, ...
                              'mr_sigma_x', params.mr_sigma_x, ...
                              'mr_max_iter', params.mr_max_iter, ...
                              'mr_tol', params.mr_tol);
                              
                          [q_f_valid_sources, info_recon_f] = manifold_regularization_solver(H_esm_f, P_f, current_valid_esm_coords, mr_params_loop);
                    
                 end
                 
                 fprintf('OK (%.2fs). ', toc(tic_solve));
                 
                 % Validate solver output
                 if isempty(q_f_valid_sources) || any(~isfinite(q_f_valid_sources(:))) || size(q_f_valid_sources,1) ~= N_esm_valid_f
                      error('Solver output invalid.');
                 end
                 
                 % Calculate residual and p_recon
                 residual_vec = H_esm_f * q_f_valid_sources - P_f;
                 current_residual = norm(residual_vec) / norm_p_f;
                 info_recon_f.relative_residual = current_residual;
                 fprintf('RelRes=%.4f. ', current_residual);
                 
                 p_recon_matrix(:, f_valid) = H_r_f * q_f_valid_sources;
                 q_esm_matrix(valid_idx_f, f_valid) = q_f_valid_sources; % Store in full grid matrix
                 all_residuals(f_valid) = current_residual;
                 info_recon_f.EquivalentSources_Locations = current_esm_points(valid_idx_f,:);
                 per_freq_recon_info{freq_idx_orig} = info_recon_f;
                 fprintf('p_recon OK.\n');
             
             catch ME_solve
                 warning('FAILED Solve/Recon Freq %.2f Hz: %s\n', current_freq, ME_solve.message);
                 per_freq_recon_info{freq_idx_orig} = struct('message',['Solve/Recon failed: ' ME_solve.message],'relative_residual',NaN);
                 % Matrices remain zero/NaN for this iteration
             end
        end % End independent frequency solve loop
    end % End if use_group_sbl
    % =======================================================================
    % --- END SOLVER STAGE ---
    % =======================================================================


    % ========================================
    % --- 5g. Filtering and Fusion Stage ---
    % ========================================
    fprintf('------------------------------------------\n');
    fprintf(' Filtering and Fusing results...\n');
    
    % Filter based on SUCCESS (non-NaN residual) and THRESHOLD
    valid_for_fusion_mask = isfinite(all_residuals) & (all_residuals <= params.multifreq_residual_threshold);
    indices_for_fusion = find(valid_for_fusion_mask); % Indices relative to the 'valid' set
    num_maps_for_fusion = length(indices_for_fusion);
    
    maps_to_fuse = zeros(params.N, params.N, 0); 
    processed_freqs_info_filtered = {}; 

    if num_maps_for_fusion > 0
        fprintf('   Found %d frequencies meeting residual threshold <= %.3f.\n', num_maps_for_fusion, params.multifreq_residual_threshold);
        maps_to_fuse = zeros(params.N, params.N, num_maps_for_fusion);
        
        for k = 1:num_maps_for_fusion
            idx_valid = indices_for_fusion(k);
            idx_orig = valid_freq_indices(idx_valid);
            
            p_recon_vec_k = p_recon_matrix(:, idx_valid);
            map_k = abs(reshape(p_recon_vec_k, params.N, params.N));
            max_val = max(map_k(:));
            
            if max_val > eps, maps_to_fuse(:,:,k) = map_k / max_val; else, maps_to_fuse(:,:,k) = 0; end
            
            % Ensure q_esm is populated
            if ~isfield(per_freq_recon_info{idx_orig}, 'q_esm') || isempty(per_freq_recon_info{idx_orig}.q_esm)
                per_freq_recon_info{idx_orig}.q_esm = q_esm_matrix(:,idx_valid);
            end
            
            processed_freqs_info_filtered{k} = per_freq_recon_info{idx_orig};
            
            % Ensure frequency metadata is included
             if ~isfield(processed_freqs_info_filtered{k}, 'frequency')
                 processed_freqs_info_filtered{k}.frequency = freq_metadata(idx_orig).frequency;
             end
        end
         fprintf('   Included Freqs (Hz): [%s]\n', sprintf('%.1f ', [freq_metadata(valid_freq_indices(indices_for_fusion)).frequency]));
    
    else % Fallback logic if no maps met threshold
        warning('Region %d: No frequency bins met the residual threshold (%.3f).', rIdx, params.multifreq_residual_threshold);
         
        % Find the minimum finite residual among all successfully processed frequencies
        valid_res_indices = find(isfinite(all_residuals));
        if isempty(valid_res_indices)
             fprintf(' ERROR: All frequency bins failed processing. Skipping region.\n');
             results{rIdx} = []; continue;
        end
        
        [min_res, best_idx_relative] = min(all_residuals(valid_res_indices));
        best_idx_valid = valid_res_indices(best_idx_relative);
        best_idx_orig = valid_freq_indices(best_idx_valid);
        
        fprintf('   -> Using only freq %.2f Hz (Best RelRes=%.4f overall).\n', freq_metadata(best_idx_orig).frequency, min_res);
        
        p_recon_best = p_recon_matrix(:, best_idx_valid);
        map_best_fallback = abs(reshape(p_recon_best, params.N, params.N));
        max_val = max(map_best_fallback(:));
        maps_to_fuse = zeros(params.N, params.N, 1);
        
        if max_val > eps, maps_to_fuse(:,:,1) = map_best_fallback / max_val; else, maps_to_fuse(:,:,1) = 0; end
        
        processed_freqs_info_filtered = {per_freq_recon_info{best_idx_orig}};
         if ~isfield(processed_freqs_info_filtered{1}, 'frequency')
             processed_freqs_info_filtered{1}.frequency = freq_metadata(best_idx_orig).frequency;
         end
        num_maps_for_fusion = 1;
    end

    % --- Perform Fusion ---
    fprintf(' Fusing results from %d valid frequency maps...\n', num_maps_for_fusion);
    
    detection_map_fused_norm = zeros(params.N, params.N);
    if num_maps_for_fusion > 0
         % Determine Fusion Method (Mean/Median/Max)
         switch lower(params.multifreq_fusion_method)
            case 'median'
                fprintf('   Using MEDIAN fusion method.\n');
                detection_map_fused_norm = median(maps_to_fuse, 3, 'omitnan');
            case 'mean'
                fprintf('   Using MEAN fusion method.\n');
                % Note: SURE weighting could be added here if desired, but simple mean is robust.
                detection_map_fused_norm = mean(maps_to_fuse, 3, 'omitnan');
            case 'max'
                 fprintf('   Using MAX fusion method.\n');
                 detection_map_fused_norm = max(maps_to_fuse, [], 3, 'omitnan');
            otherwise
                 fprintf('   Using Default (MEDIAN) fusion method.\n');
                 detection_map_fused_norm = median(maps_to_fuse, 3, 'omitnan');
         end
        detection_map_fused_norm(isnan(detection_map_fused_norm)) = 0;
    else
         fprintf('   Fusion skipped (no valid maps).\n');
    end
    fprintf(' Fusion complete.\n');

    % ========================================
    % --- 5h. Post-processing and Thresholding ---
    % ========================================
    fprintf(' Step 7: Post-process fused map...\n');
    detection_map_raw = detection_map_fused_norm;
    detection_map_smooth = detection_map_raw;
    
    % Apply smoothing
    if any(detection_map_raw(:) > eps)
        try 
            sigma_smooth = 0.5; % Smoothing kernel size
            detection_map_smooth = imgaussfilt(detection_map_raw, sigma_smooth);
        catch ME_smooth
            fprintf(' Gauss smooth failed (Image Processing Toolbox required?): %s\n', ME_smooth.message); 
            detection_map_smooth = detection_map_raw; 
        end
    end
    detection_map_smooth(detection_map_smooth<0)=0; 
    detection_map_smooth(isnan(detection_map_smooth)) = 0;

    fprintf(' Step 8: Apply thresholding to fused map...\n');
    final_threshold = params.detection_threshold; 
    beetle_detected = false(size(detection_map_smooth));
    
    % Check if map is valid for adaptive thresholding
    map_is_valid_for_adapt = false;
    if ~isempty(detection_map_smooth) && isnumeric(detection_map_smooth)
        map_finite_vals = detection_map_smooth(isfinite(detection_map_smooth));
        if ~isempty(map_finite_vals) && max(map_finite_vals) > min(map_finite_vals) + eps
            map_is_valid_for_adapt = true;
        end
    end
    
    % Apply thresholding
    if params.use_adaptive_threshold && map_is_valid_for_adapt
        % Requires the adaptive_threshold_detection function
        try
            [temp_mask, temp_threshold] = adaptive_threshold_detection(detection_map_smooth);
            if isnumeric(temp_threshold) && isscalar(temp_threshold) && isfinite(temp_threshold)
                final_threshold = temp_threshold; 
                beetle_detected = temp_mask & isfinite(detection_map_smooth);
                fprintf('   Adaptive threshold: %.4f\n', final_threshold);
            else
                error('Adaptive threshold returned invalid value.');
            end
        catch ME_adapt
            fprintf('Adaptive threshold failed (%s). Using fixed threshold %.2f', ME_adapt.message, params.detection_threshold);
            final_threshold = params.detection_threshold;
            if ~isempty(detection_map_smooth), beetle_detected = (detection_map_smooth > final_threshold) & isfinite(detection_map_smooth); end
        end
    else
        final_threshold = params.detection_threshold;
        fprintf('   Using Fixed threshold: %.4f (Adaptive disabled or map invalid/constant)\n', final_threshold);
        if ~isempty(detection_map_smooth), beetle_detected = (detection_map_smooth > final_threshold) & isfinite(detection_map_smooth); end
    end
    
    % Safety checks on threshold value
    if final_threshold <= 0 || final_threshold >= 1
        warning('Threshold %.4f outside range (0, 1). Clamping to 0.3.', final_threshold); final_threshold = 0.3;
        if ~isempty(detection_map_smooth), beetle_detected = (detection_map_smooth > final_threshold) & isfinite(detection_map_smooth); end
    end
    if ~isempty(detection_map_smooth), beetle_detected(isnan(detection_map_smooth)) = false; end

    % ==================================
    % --- 5i. Store Final Results ---
    % ==================================
    fprintf(' Step 9: Store fused results for region %d.\n', rIdx);
    
    % Determine the final reconstruction information struct to report
    final_peak_H_condition = NaN;
    final_recon_info = struct(... % Default failure info
                'message','ERROR: No valid frequency found/processed or fused', ...
                'termination_reason','Failure', 'iterations',NaN, 'relative_residual',NaN, ...
                'EquivalentSources_Locations',[], 'opt_status', recon_info.opt_status);

    % Determine which info struct to use for the final report
    report_info_struct = [];
    
    if use_group_sbl && ~isempty(group_recon_info) 
        % Prioritize group SBL info if it ran
        final_recon_info = group_recon_info;
        % Find info for peak frequency *within the valid set* used by group SBL
        peak_freq_valid_idx = find(abs([freq_metadata_valid.frequency] - peakFreq) < 1e-3, 1);
        
        if ~isempty(peak_freq_valid_idx)
             peak_freq_orig_idx = valid_freq_indices(peak_freq_valid_idx);
             final_peak_H_condition = freq_metadata(peak_freq_orig_idx).H_condition;
             final_peakFreq = freq_metadata(peak_freq_orig_idx).frequency;
             % Add peak residual to group info message
             peak_resid_for_group = all_residuals(peak_freq_valid_idx);
             final_recon_info.message = sprintf('%s (PeakResid:%.4f)',final_recon_info.message, peak_resid_for_group);
             % Add representative locations
             if ~isempty(per_freq_recon_info{peak_freq_orig_idx}) && isfield(per_freq_recon_info{peak_freq_orig_idx},'EquivalentSources_Locations')
                  final_recon_info.EquivalentSources_Locations = per_freq_recon_info{peak_freq_orig_idx}.EquivalentSources_Locations;
             end
        else
             final_peakFreq = NaN; % Peak wasn't in the valid set
        end

    elseif ~isempty(processed_freqs_info_filtered) 
        % If independent solvers AND fusion happened (or fallback used)
        
        % Try to find the original peak freq among the FILTERED results
        peak_report_idx_filtered = [];
        try
             filtered_freqs = cellfun(@(s) s.frequency, processed_freqs_info_filtered);
             peak_report_idx_filtered = find(abs(filtered_freqs - peakFreq) < 1e-3, 1);
        catch ME_find_peak, disp('Error finding peak freq index in filtered list.'); end
        
        if ~isempty(peak_report_idx_filtered)
            % Peak frequency was successfully fused
            report_info_struct = processed_freqs_info_filtered{peak_report_idx_filtered};
            final_peakFreq = report_info_struct.frequency;
            orig_idx_for_peak_fused = find(abs([freq_metadata.frequency] - final_peakFreq) < 1e-3, 1);
             if ~isempty(orig_idx_for_peak_fused), final_peak_H_condition = freq_metadata(orig_idx_for_peak_fused).H_condition; end
        
        else 
            % Peak not fused (or fallback was used), use first available frequency for report
            report_info_struct = processed_freqs_info_filtered{1};
            final_peakFreq = report_info_struct.frequency;
            orig_idx_for_first_fused = find(abs([freq_metadata.frequency] - final_peakFreq) < 1e-3, 1);
             if ~isempty(orig_idx_for_first_fused), final_peak_H_condition = freq_metadata(orig_idx_for_first_fused).H_condition; end
            
            if abs(peakFreq - final_peakFreq) > 1e-3
                warning('Peak frequency %.2f Hz not fused. Reporting info for freq %.2f Hz instead.', peakFreq, final_peakFreq);
            end
        end
        final_recon_info = report_info_struct; % Overwrite default failure info
    
    else 
        % Safety measure if all processing failed
        warning('Region %d: No frequencies processed successfully.', rIdx);
        final_peakFreq = peakFreq;
    end
    
     % Add GA info if applicable
     if ga_active
        % Merge GA results into final_recon_info...
     end

    % --- Create the final results struct ---
    if ~isempty(processed_freqs_info_filtered)
        try
            processed_freq_list_final = cellfun(@(s) s.frequency, processed_freqs_info_filtered);
        catch
            processed_freq_list_final = [];
        end
    else
         processed_freq_list_final = [];
    end
    
    % Best relative residual among all processed freqs
    best_rel_res = min(all_residuals(isfinite(all_residuals)));
    if isempty(best_rel_res), best_rel_res = NaN; end
    
    regionResult = struct(...
        'ID', rIdx, 'tStart', region.t_start, 'tEnd', region.t_end, ...
        'ProcessedFrequencies', processed_freq_list_final, ... % Frequencies actually fused
        'PeakFrequency', final_peakFreq, ... 
        'Method', params.method, 'SolverUsed', solver_display_name, ...
        'PropagatorMethod', prop_method_summary, 'MultiFreqStatus', mf_status, 'MultiFreqFusionMethod', params.multifreq_fusion_method, ...
        'MediumType', params.medium_type, 'LayerMaterial', params.layer_material, 'LayerThickness', params.layer_thickness, 'DistMicToFrontSurface', params.dist_mic_to_front_surface, ...
        'ESM_DeltaZ_Factor', params.esm_delta_z_factor, 'ESM_DeltaZ_Absolute', params.esm_delta_z, ...
        'H_MatrixCondition', final_peak_H_condition, ...
        'MeasuredPressureVec', p_meas_vec_peak, ...
        'IndividualFreqInfo', {processed_freqs_info_filtered}, ... % Info for fused frequencies ONLY
        'FusionWeights', [], ... % Weights not explicitly calculated (e.g. SURE removed for simplicity)
        'DetectionMapFusedNorm', detection_map_fused_norm, ...
        'DetectionMapSmooth', detection_map_smooth, ...
        'DetectionThreshold', final_threshold, ...
        'DetectedMask', beetle_detected, ...
        'BestRelativeResidual', best_rel_res, ...
        'ReconstructionInfo', final_recon_info);
    
    % Add grid info if available (from Section 3)
    if exist('X_grid', 'var'), regionResult.X_grid = X_grid; end
    if exist('Y_grid', 'var'), regionResult.Y_grid = Y_grid; end

    results{rIdx} = regionResult;
    
    fprintf('Finished processing Region %d.\n', rIdx);
    fprintf('=================================================\n');
end % End loop over regions (rIdx)
disp('------------------------------------------');


%% 6. Visualize Results %%% <<< UPDATED FOR MULTI-FREQ >>>
fprintf('\n--- Generating ESM Visualizations (%s Solver, %s, Prop: %s, %s) ---\n', ... %%% <<< UPDATED
    upper(params.method), params.medium_type, prop_method_summary, mf_status);
numProcessedRegions = sum(~cellfun('isempty', results));
if numProcessedRegions == 0, fprintf(' No regions processed successfully.\n');
else, fprintf(' Generating plots for %d region(s)...\n', numProcessedRegions);
    processedCount = 0;
    for rIdx = 1:length(results)
        if isempty(results{rIdx}), continue; end
        processedCount = processedCount + 1; thisRes = results{rIdx};
        scale_method_amp = 'lanczos3'; scale_method_bin = 'nearest';

        % --- Create default empty/zero maps for robustness ---
        zero_map_N = zeros(params.N);
        zero_map_scaled = zeros(params.N * params.scaleFactor); % Use this if resize fails

        % --- Plots need adjustment for multi-frequency ---
        % Plot 1: Measured Pressure Map (Keep as is, based on peak freq p_meas)
        meas_vec = thisRes.MeasuredPressureVec; meas_grid_amp_approx = zeros(params.N);
        x_mic_coords = params.mic_coords_raw(:,1); y_mic_coords = params.mic_coords_raw(:,2);
        x_grid_vec = linspace(min(x_mic_coords), max(x_mic_coords), params.N); y_grid_vec = linspace(min(y_mic_coords), max(y_mic_coords), params.N);
        for k_map = 1:params.numMics, [~, gc] = min(abs(x_grid_vec - x_mic_coords(k_map))); [~, gr] = min(abs(y_grid_vec - y_mic_coords(k_map))); if k_map <= length(meas_vec), meas_grid_amp_approx(gr, gc) = meas_grid_amp_approx(gr, gc) + abs(meas_vec(k_map)); end; end
        meas_grid_amp_disp = imresize(meas_grid_amp_approx, params.scaleFactor, scale_method_amp);

        % Plot 2: Equivalent Source Strengths Map - NEEDS RECONSIDERATION
        q_grid_amp = zero_map_N; % Default to zero map
        q_plot_title = {'2. Equiv Src |q_{esm}|';'(Peak Freq - Not Available)'}; % Default title

        % Guard against an empty IndividualFreqInfo cell array
        peak_info_idx = []; % Initialize
        if ~isempty(thisRes.IndividualFreqInfo)
            try % Add try-catch for safety during cellfun/find
                freq_list = cellfun(@(s) s.frequency, thisRes.IndividualFreqInfo);
                peak_info_idx = find(freq_list == thisRes.PeakFrequency, 1);
            catch ME_find % Handle potential error if structs are malformed
                disp('Error finding peak frequency index in IndividualFreqInfo: %s', ME_find.message);
                peak_info_idx = [];
            end
        end

        % --- CORRECTED Q_ESM LOGIC ---
        % Check if peak_info_idx is valid AND if q_esm exists and is non-empty for that index
        if ~isempty(peak_info_idx) && ...
           isfield(thisRes.IndividualFreqInfo{peak_info_idx},'q_esm') && ...
           ~isempty(thisRes.IndividualFreqInfo{peak_info_idx}.q_esm) && ...
           isfield(thisRes.IndividualFreqInfo{peak_info_idx},'EquivalentSources_Locations') && ...
           ~isempty(thisRes.IndividualFreqInfo{peak_info_idx}.EquivalentSources_Locations)
        
            q_vec_peak = thisRes.IndividualFreqInfo{peak_info_idx}.q_esm;
            q_locs     = thisRes.IndividualFreqInfo{peak_info_idx}.EquivalentSources_Locations;
            q_plot_title = {sprintf('2. Equiv Src |q_{esm}| (%.1f Hz)', thisRes.PeakFrequency)};
                     % Attempt mapping (assuming N_side^2 sources)
             if numel(q_vec_peak) == params.N^2
                 try
                     q_grid_amp = abs(reshape(q_vec_peak, params.N, params.N));
                 catch ME_reshape
                     warning('Region %d: Reshape failed for q_esm (Size %s). Using fallback mapping.', rIdx, mat2str(size(q_vec_peak)));
                     % Fallback mapping (slower, more robust to non-grid sources if locations were different)
                     x_recon_vec = unique(params.recon_points(:,1)); y_recon_vec = unique(params.recon_points(:,2));
                     for k_q = 1:length(q_vec_peak)
                         if k_q <= size(q_locs,1)
                             [~, c] = min(abs(x_recon_vec - q_locs(k_q, 1)));
                             [~, r] = min(abs(y_recon_vec - q_locs(k_q, 2)));
                             q_grid_amp(r, c) = q_grid_amp(r, c) + abs(q_vec_peak(k_q));
                         end
                     end
                 end
             else
                  warning('Region %d: Size mismatch for q_esm grid mapping (%d vs %d). Using fallback.', rIdx, numel(q_vec_peak), params.N^2);
                 % Fallback mapping
                 x_recon_vec = unique(params.recon_points(:,1)); y_recon_vec = unique(params.recon_points(:,2));
                 for k_q = 1:length(q_vec_peak)
                      if k_q <= size(q_locs,1)
                         [~, c] = min(abs(x_recon_vec - q_locs(k_q, 1)));
                         [~, r] = min(abs(y_recon_vec - q_locs(k_q, 2)));
                         q_grid_amp(r, c) = q_grid_amp(r, c) + abs(q_vec_peak(k_q));
                      end
                 end
             end
        else
             % This executes if peak_info_idx empty OR q_esm empty/missing OR locations missing
             warning('Could not retrieve valid q_esm or locations for peak frequency plot (Index: %s). Plotting zeros.', num2str(peak_info_idx));
             q_grid_amp = zero_map_N; % Ensure it's zero
             q_plot_title = {'2. Equiv Src |q_{esm}|';'(Peak Freq - Not Available)'}; % Update title
        end
        % Resize the q_esm map (will be zeros if retrieval failed)
        q_grid_amp_disp = imresize(q_grid_amp, params.scaleFactor, scale_method_amp);
        % --- END CORRECTED Q_ESM LOGIC ---


        % Plot 3: Fused Normalized Recon Pressure |p_r|
        % --- ADDED CHECK FOR EMPTY FUSED MAP ---
        if isempty(thisRes.DetectionMapFusedNorm)
             warning('Region %d: Fused detection map is empty. Plotting zeros.', rIdx);
             raw_recon_disp = zero_map_scaled; % Use scaled zero map
        else
             raw_recon_disp = imresize(thisRes.DetectionMapFusedNorm, params.scaleFactor, scale_method_amp);
        end
        % --- END ADDED CHECK ---

        % Plot 4: Phase - Omitted/Placeholder
        phase_map_disp = raw_recon_disp; % Placeholder uses the (potentially zero) raw map display
        phase_plot_title = '4. Fused |p_r| (Phase Omitted)';

        % Plot 5: Smoothed Fused Normalized Map |p_r|
        % --- ADDED CHECK FOR EMPTY SMOOTHED MAP ---
         if isempty(thisRes.DetectionMapSmooth)
             warning('Region %d: Smoothed detection map is empty. Plotting zeros.', rIdx);
             smooth_recon_disp = zero_map_scaled;
        else
            smooth_recon_disp = imresize(thisRes.DetectionMapSmooth, params.scaleFactor, scale_method_amp);
         end
        % --- END ADDED CHECK ---

        % Plots 6, 7: Based on thresholded smoothed fused map
        % --- ADDED CHECK FOR EMPTY MASK ---
        if isempty(thisRes.DetectedMask)
             warning('Region %d: Detected mask is empty. Plotting zeros.', rIdx);
             detected_mask_disp = zero_map_scaled;
             boundaries = []; % No boundaries if mask is empty
        else
            detected_mask_disp = imresize(double(thisRes.DetectedMask), params.scaleFactor, scale_method_bin);
            try % Boundary calculation might fail if mask is strange
                 boundaries = bwboundaries(thisRes.DetectedMask); % Use original mask for bwboundaries
            catch ME_bound
                warning('Region %d: bwboundaries failed: %s', rIdx, ME_bound.message);
                boundaries = [];
            end
        end
        % --- END ADDED CHECK ---


        % --- Plotting ---
        peak_freq_str = sprintf('Peak Freq=%.2fHz', thisRes.PeakFrequency);
        % Corrected frequency info display logic
        if ~isempty(thisRes.ProcessedFrequencies)
             num_freqs_processed = length(thisRes.ProcessedFrequencies);
             freq_range_str = sprintf('[%.1f-%.1f]Hz', min(thisRes.ProcessedFrequencies), max(thisRes.ProcessedFrequencies));
             num_freqs_str = sprintf('%d Freqs %s', num_freqs_processed, freq_range_str);
        else
            num_freqs_str = '0 Freqs Processed';
        end
        % Use safe fusion weights display logic
        weights_str = 'N/A';
        if isfield(thisRes,'FusionWeights') && ~isempty(thisRes.FusionWeights) && length(thisRes.FusionWeights) > 1
            weights_str = sprintf('[%.3f ... %.3f]', min(thisRes.FusionWeights), max(thisRes.FusionWeights));
        elseif isfield(thisRes,'FusionWeights') && ~isempty(thisRes.FusionWeights) && length(thisRes.FusionWeights) == 1
             weights_str = sprintf('[%.3f]', thisRes.FusionWeights);
        end

        figH = figure('Name', sprintf('ESM NAH Region %d (%s, %s, %s, %s)', thisRes.ID, thisRes.Method, thisRes.MediumType, thisRes.PropagatorMethod, thisRes.MultiFreqStatus), 'Position', get(0,'Screensize').*[0.02 0.05 0.95 0.85]);
        sgtitle(sprintf('Region %d: ESM NAH Results (%s, Time: %.2fs-%.2fs, %s, %s, Solver: %s, Prop: %s)', thisRes.ID, thisRes.MediumType, thisRes.tStart, thisRes.tEnd, peak_freq_str, thisRes.MultiFreqStatus, upper(thisRes.Method), thisRes.PropagatorMethod), 'FontWeight','bold','FontSize',12);
        x_ticks_num = min(params.N, 7); y_ticks_num = min(params.N, 7); x_pos = linspace(1, params.N*params.scaleFactor, x_ticks_num); y_pos = linspace(1, params.N*params.scaleFactor, y_ticks_num);
        recon_grid_x_vec = params.recon_points(:,1); recon_grid_y_vec = params.recon_points(:,2); x_labels_cm = sprintf('%.2f\n', linspace(min(recon_grid_x_vec), max(recon_grid_x_vec), x_ticks_num) * 100); y_labels_cm = sprintf('%.2f\n', linspace(min(recon_grid_y_vec), max(recon_grid_y_vec), y_ticks_num) * 100);
        cmX = 'X (cm)'; cmY = 'Y (cm)'; ydir_args = {'YDir', 'reverse'};

        ax1=subplot(2,4,1); imagesc(meas_grid_amp_disp); axis image; colormap(ax1,hot); colorbar; title({'1. Measured |P_{meas}|';sprintf('(at Peak Freq %.1fHz)', thisRes.PeakFrequency)}); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:});
        ax2=subplot(2,4,2); imagesc(q_grid_amp_disp); axis image; colormap(ax2,hot); colorbar; title(q_plot_title); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:}); % Use dynamic title
        ax3=subplot(2,4,3); imagesc(raw_recon_disp); axis image; colormap(ax3, hot); colorbar; clim([0 1]); title({'3. Fused Recon |p_r|';sprintf('(%s, %s)', thisRes.MultiFreqStatus, thisRes.MultiFreqFusionMethod)}); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:});
        ax4=subplot(2,4,4); imagesc(phase_map_disp); axis image; colormap(ax4, hot); colorbar; clim([0 1]); title(phase_plot_title); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:}); % Updated title
        ax5=subplot(2,4,5); imagesc(smooth_recon_disp); axis image; colormap(ax5, hot); colorbar; clim([0 1]); title('5. Fused |p_r| Smoothed'); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:});
        ax6=subplot(2,4,6); imagesc(detected_mask_disp); axis image; colormap(ax6, gray); colorbar; clim([0 1]); title({'6. Detected Pixels'; sprintf('(Thresh=%.3f)', thisRes.DetectionThreshold)}); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:});
        ax7=subplot(2,4,7); imagesc(smooth_recon_disp); axis image; colormap(ax7, hot); colorbar; clim([0 1]); hold on;
        % --- Corrected Boundary Plotting ---
        if ~isempty(boundaries)
             visboundaries(boundaries, 'Color','g','LineWidth',1); % Use boundaries calculated earlier
        end
        hold off; title('7. Detection Boundary'); xlabel(cmX);ylabel(cmY); xticks(x_pos);xticklabels(x_labels_cm);yticks(y_pos);yticklabels(y_labels_cm);set(gca,ydir_args{:});
        % --- End Corrected Boundary Plotting ---


        % Plot 8: Reconstruction Info

         ax8=subplot(2,4,8); axis off;
         info_struct = thisRes.ReconstructionInfo; % Info primarily from peak/best freq run
         res_text = {sprintf('8. Solver: %s (%s)', upper(thisRes.Method), thisRes.MediumType)};
         res_text{end+1} = [' Propagator: ', thisRes.PropagatorMethod];
         res_text{end+1} = sprintf(' Freq Proc: %s (%s)', thisRes.MultiFreqStatus, num_freqs_str);
         res_text{end+1} = sprintf(' Fusion Wts: %s', weights_str);
         res_text{end+1} = sprintf(' Best RelRes: %.4f', thisRes.BestRelativeResidual);

         % --- ADD Filtered Residual Info ---
         if ~isempty(thisRes.IndividualFreqInfo) % Check if any freq info exists
             try % Use try-catch for safety
                all_res = cellfun(@(s) s.relative_residual, thisRes.IndividualFreqInfo);
                valid_res = all_res(isfinite(all_res)); % Only consider finite residuals
                if ~isempty(valid_res)
                    res_text{end+1} = sprintf(' FiltRes (Min/Mn/Mx): %.3f/%.3f/%.3f', min(valid_res), mean(valid_res), max(valid_res));
                else
                     res_text{end+1} = ' FiltRes: N/A (No valid residuals)';
                end
             catch ME_res_disp
                 res_text{end+1} = sprintf(' FiltRes: Error (%s)', ME_res_disp.message);
             end
         end
         % --- END Residual Info ---
         % --- END CORRECTION ---
         text(0.05, 0.5, res_text, 'VerticalAlignment', 'middle', 'FontSize', 8);
         title('8. Recon Details');

        try drawnow; catch ME_drawnow; fprintf(' Draw error: %s\n', ME_drawnow.message); end
    end % End loop plotting regions
    fprintf(' Visualizations complete for %d region(s).\n', processedCount);
end
disp('------------------------------------------');

% %% 7. Save Results
% % (Code identical to previous version, added mf_tag - omitted for brevity)
% saveResults = input('Save results structure to .mat file? (y/N): ','s');
% if ~isempty(saveResults) && lower(saveResults(1)) == 'y' && numProcessedRegions > 0
%     timestamp = datestr(now,'yyyymmdd_HHMMSS');
%     try [parentDir, expName] = fileparts(storageLocation); if strcmp(expName,'RecordingGroup'), [~, expName] = fileparts(parentDir); end; if isempty(expName), expName = 'Experiment'; end catch; expName = 'Experiment'; parentDir = pwd; end
%     prop_tag = iif(params.use_kwave_propagator,'kWave','TMM'); % Use TMM tag
%     opt_tag = iif(ga_active,'OptGA','NoOpt');
%     mf_tag = iif(params.use_multifreq,'MultiFreq','SingleFreq'); % Add multi-freq tag
%     defaultName = sprintf('ExpNAH_ESMmulti_Results_%s_%s_%s_%s_%s_%s.mat', expName, params.method, prop_tag, opt_tag, mf_tag, timestamp); % Add mf_tag
%     saveFilename = fullfile(parentDir, defaultName);
%     [file, path] = uiputfile('*.mat', 'Save Results As', saveFilename);
%     if isequal(file,0) || isequal(path,0), fprintf(' Saving cancelled.\n');
%     else fullpath = fullfile(path, file); try fprintf(' Saving results to: %s\n', fullpath); for i=1:length(results), if ~isempty(results{i}) && isfield(results{i},'ReconstructionInfo') && isfield(results{i}.ReconstructionInfo,'ga_output'), fprintf('   -> Pruning GA results{%d}\n',i); results{i}.ReconstructionInfo.ga_output = rmfield_safe(results{i}.ReconstructionInfo.ga_output, {'population','scores'}); end; end; save(fullpath, 'params', 'results', 'microphonePositions', 'sampleRate', 'storageLocation', 'timestamp', '-v7.3'); fprintf(' Results saved.\n'); catch ME_save, fprintf('\n !!! ERROR SAVING RESULTS: %s !!!\n', ME_save.message); try for i=1:length(results), if ~isempty(results{i}) && isfield(results{i},'ReconstructionInfo') && isfield(results{i}.ReconstructionInfo,'ga_output'), results{i}.ReconstructionInfo = rmfield(results{i}.ReconstructionInfo,'ga_output'); end; end; save(fullpath, 'params', 'results', 'microphonePositions', 'sampleRate', 'storageLocation', 'timestamp', '-v7.3'); fprintf('   Results saved without full GA output.\n'); catch ME_save2, fprintf('\n !!! FAILED TO SAVE RESULTS AGAIN: %s !!!\n', ME_save2.message); end; end; end
% else, fprintf(' Results not saved.\n'); end
% fprintf('\n--- Analysis Complete ---\n');
fprintf('\n--- Analysis Complete ---\n');



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  >>> HELPER FUNCTIONS <<<                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% --- Material Properties Database --- %%% ADDED alpha_power %%%
function materials = create_material_properties()
    fprintf('Loading material properties...\n');
    materials = struct();
    materials.air.name = 'Air'; materials.air.c = 343.0; materials.air.rho = 1.225; materials.air.alpha_dB_m = 0.01; materials.air.alpha_freq_Hz = 5000; materials.air.alpha_power = 1.8;
    materials.teflon.name = 'Teflon (PTFE)'; materials.teflon.c = 725; materials.teflon.rho = 2200; materials.teflon.alpha_dB_m = 50; materials.teflon.alpha_freq_Hz = 1e6; materials.teflon.alpha_power = 1.5; % * density is kilograms per cubic meter ( kg/m )
    materials.pine_bark.name = 'Pine Bark'; materials.pine_bark.c = 475; materials.pine_bark.rho = 500; materials.pine_bark.alpha_dB_m = 200; 
    materials.pine_bark.alpha_freq_Hz = 5000; materials.pine_bark.alpha_power = 1.2; % 
    fprintf('Loaded properties for: %s\n', strjoin(fieldnames(materials), ', '));
    disp('!!! WARNING: Material properties are placeholders/guesses and require verification !!!');
end

% --- Complex Wavenumber Helper --- %%% Uses Power Law %%%
function k_complex = get_complex_wavenumber(material_props, omega)
    f = omega / (2*pi); c = material_props.c; alpha_dB_m_ref = material_props.alpha_dB_m; alpha_freq_ref = material_props.alpha_freq_Hz;
    if isfield(material_props, 'alpha_power'), alpha_power = material_props.alpha_power; else alpha_power = 1.0; end
    if alpha_freq_ref > 1e-6 && f > 1e-6 && alpha_dB_m_ref > 0, alpha_dB_m = alpha_dB_m_ref * (f / alpha_freq_ref)^alpha_power; else alpha_dB_m = alpha_dB_m_ref; end
    alpha_Np_m = alpha_dB_m / 8.685889638; k_complex = omega / c - 1i * alpha_Np_m; if abs(omega) < 1e-9, k_complex = 0 - 1i * alpha_Np_m; end
end

% --- Complex Impedance Helper ---
function Z_complex = get_complex_impedance(material_props, omega, k_complex)
    rho = material_props.rho; if abs(k_complex) < 1e-15, Z_complex = rho * material_props.c; if abs(omega)>1e-9, warning('k_complex is near zero.'); end; else Z_complex = rho * omega / k_complex; end
end

% --- Normal Incidence Transmission Coefficient Helper ---
function T = get_transmission_coeff(Z1, Z2)
    if abs(Z1 + Z2) < 1e-15, warning('Sum of impedances near zero.'); T = 0; else T = (2 * Z2) / (Z1 + Z2); end
end

% --- REVISED Multi-Layer Green's Function ---
function [G, deleteIndexesVirt, N_virt_valid] = Green_matrix_multilayer_revised(hologramPoints, virtualPoints, omega, layer_info)
    % Calculates Green function using straight-line path and normal incidence T.
    if size(hologramPoints,2) ~= 3 || size(virtualPoints,2) ~= 3, error('Input points must be M x 3.'); end
    nan_rows_virt = find(any(isnan(virtualPoints), 2)); deleteIndexesVirt = nan_rows_virt;
    if ~isempty(deleteIndexesVirt), virtualPoints(deleteIndexesVirt,:) = []; end
    nan_rows_holo = find(any(isnan(hologramPoints), 2));
    if ~isempty(nan_rows_holo), warning('Removing %d hologram points with NaN coords!', length(nan_rows_holo)); hologramPoints(nan_rows_holo,:) = []; end
    N_hologram = size(hologramPoints, 1); N_virt_initial = size(virtualPoints, 1); N_virt_valid = N_virt_initial; % N_virt_valid will be updated
    if N_virt_initial == 0 || N_hologram == 0, warning('No valid points after NaN removal.'); G = {}; return; end

    mat_db=layer_info.db; props_front=mat_db.(layer_info.material_air_front_name); props_layer=mat_db.(layer_info.layer_material_name); props_back=mat_db.(layer_info.material_air_back_name);
    k_front=get_complex_wavenumber(props_front, omega); k_layer=get_complex_wavenumber(props_layer, omega); k_back=get_complex_wavenumber(props_back, omega);
    Z_front=get_complex_impedance(props_front, omega, k_front); Z_layer=get_complex_impedance(props_layer, omega, k_layer); Z_back=get_complex_impedance(props_back, omega, k_back);
    T_back_layer = get_transmission_coeff(Z_back, Z_layer); T_layer_front = get_transmission_coeff(Z_layer, Z_front);
    z_if_front = layer_info.z_interface_front; z_if_back = layer_info.z_interface_back; is_air_only = strcmpi(layer_info.medium_type, 'air_only') || abs(layer_info.thickness) < 1e-9;
    if is_air_only, T_back_layer=1; T_layer_front=1; k_layer=k_front; k_back=k_front; end % Simplify for air only

    G_w = complex(zeros(N_hologram, N_virt_initial)); tiny_dist = 1e-9;

    for jj = 1:N_virt_initial
        r_v = virtualPoints(jj, :); zv = r_v(3);
        for ii = 1:N_hologram
            r_h = hologramPoints(ii, :); zh = r_h(3);
            R_vec = r_h - r_v; R_mag = norm(R_vec, 2); if R_mag < tiny_dist, R_mag = tiny_dist; end
            spherical_spreading = 1 / (4 * pi * R_mag);
            if R_mag > tiny_dist, uz = R_vec(3) / R_mag; else uz = sign(zh - zv); end % Use sign if coincident
            if abs(uz) < eps, uz = sign(uz)*eps; end % Avoid uz=0

            d_back=0; d_layer=0; d_front=0; T_factor=1.0; k1=k_front; k2=k_front; k3=k_front; % Default path in front medium

            if ~is_air_only
                 t_back = (z_if_back - zv) / uz; t_front = (z_if_front - zv) / uz;
                 if zv < z_if_back % Source in Back Medium
                     k1 = k_back;
                     if zh > z_if_front % Receiver in Front Medium (Back -> Layer -> Front)
                         if t_back > tiny_dist && t_front > t_back + tiny_dist && R_mag > t_front + tiny_dist, d_back=t_back; d_layer=t_front-t_back; d_front=R_mag-t_front; T_factor=T_back_layer*T_layer_front; k2=k_layer; k3=k_front; else d_front = R_mag; T_factor=1.0; k1=k_front; k2=k_front; k3=k_front; end
                     elseif zh >= z_if_back && zh <= z_if_front % Receiver in Layer (Back -> Layer)
                         if t_back > tiny_dist && R_mag > t_back + tiny_dist, d_back = t_back; d_layer = R_mag - t_back; d_front = 0; T_factor = T_back_layer; k2=k_layer; k3=k_front; else d_front = R_mag; T_factor=1.0; k1=k_front; k2=k_front; k3=k_front; end
                     else % Receiver in Back Medium (Back)
                         d_back = R_mag; d_layer = 0; d_front = 0; T_factor = 1.0; k2=k_layer; k3=k_front;
                     end
                 elseif zv >= z_if_back && zv <= z_if_front % Source in Layer Medium
                     k1 = k_layer;
                     if zh > z_if_front % Receiver in Front Medium (Layer -> Front)
                         if t_front > tiny_dist && R_mag > t_front + tiny_dist, d_back = 0; d_layer = t_front; d_front = R_mag - t_front; T_factor = T_layer_front; k2=k_layer; k3 = k_front; else d_front = R_mag; T_factor=1.0; k1=k_front; k2=k_front; k3=k_front; end
                     elseif zh >= z_if_back && zh <= z_if_front % Receiver in Layer (Layer)
                         d_back = 0; d_layer = R_mag; d_front = 0; T_factor = 1.0; k2=k_layer; k3=k_front;
                     else % Receiver in Back Medium (Layer -> Back)
                         T_layer_back = get_transmission_coeff(Z_layer, Z_back);
                         if t_back < -tiny_dist && abs(t_back) < R_mag - tiny_dist, d_back = R_mag - abs(t_back); d_layer = abs(t_back); d_front = 0; T_factor = T_layer_back; k2 = k_back; k3=k_front; else d_front = R_mag; T_factor=1.0; k1=k_front; k2=k_front; k3=k_front; end
                     end
                 else % Source in Front Medium
                     k1 = k_front; d_back=0; d_layer=0; d_front=R_mag; T_factor=1.0; k2=k_front; k3=k_front; % Approx
                 end
                 if abs(d_back + d_layer + d_front - R_mag) > R_mag*1e-3 || d_back<0 || d_layer<0 || d_front<0, d_back=0; d_layer=0; d_front=R_mag; k1=k_front; k2=k_front; k3=k_front; T_factor=1.0; end % Sanity check fallback
            else d_front = R_mag; end % is_air_only = true

            propagation_factor = exp(1i * (k1 * d_back + k2 * d_layer + k3 * d_front)); % Note: k is omega/c - i*alpha, so use +1i here
            G_w(ii, jj) = T_factor * spherical_spreading * propagation_factor;
            if ~isfinite(G_w(ii, jj)), warning('Non-finite Green function G(%d,%d). Setting to 0.', ii, jj); G_w(ii, jj) = 0; end % Check NaN/Inf
        end
    end
    if ~isempty(deleteIndexesVirt), G_w(:, deleteIndexesVirt) = []; end % Remove columns for initial NaNs
    N_virt_valid = size(G_w, 2); G = {G_w};
end

% --- Sorama Data Loading Stubs ---
function [data, sampleRate, nrOfSamples, nrOfChannels, microphonePositions] = readRecordingGroup(storageLocation, duration, start)
    if ~exist('duration','var'), duration = inf; end; if ~exist('start','var'), start = 0; end
    containerPath = fullfile(storageLocation, "container.json"); if ~exist(containerPath, 'file'), error('container.json not found: %s', storageLocation); end
    groupContainer = readFileAsJson(containerPath); step = groupContainer.metadata.steps(1); recId = step.recordingId;
    recPath = fullfile(storageLocation, "..", "..", "Recording", recId); if ~exist(recPath, 'dir'), recPath = fullfile(storageLocation, recId); if ~exist(recPath, 'dir'), error('Cannot find Recording folder: %s', recId); end; end
    recContainerPath = fullfile(recPath, "container.json"); if ~exist(recContainerPath, 'file'), error('container.json not found in Recording folder: %s', recPath); end
    recContainer = readFileAsJson(recContainerPath); nrCh = recContainer.metadata.files.sound.frontEnd.microphoneCount; if isfield(recContainer.metadata, 'sampleRate'), sampleRate = recContainer.metadata.sampleRate; else sampleRate = 46875; end
    chOrder = recContainer.metadata.files.sound.channelOrdering + 1; micPos = recContainer.metadata.files.sound.frontEnd.microphonePositions; micPos = [vertcat(micPos.X) vertcat(micPos.Y) vertcat(micPos.Z)]; microphonePositions = micPos(chOrder,:);
    sndFile = recContainer.files.sound; sndPath = fullfile(recPath, sndFile); nrSamp = duration * sampleRate; startSamp = start * sampleRate;
    data_T = readRawSoundFile(sndPath, nrCh, nrSamp, startSamp); data = data_T'; nrOfSamples = size(data,1); nrOfChannels = nrCh;
end
function json = readFileAsJson(path), fid = fopen(path); if fid == -1, error('Cannot open file: %s', path); end, raw = fread(fid, inf); fclose(fid); json = jsondecode(char(raw')); end
function data = convertRawToPascal(data_samples_x_channels, micSens), dbSplMax = 94 - micSens; p_rms_max = 10^((dbSplMax - 94)/20); factor = p_rms_max / (2^31); data = double(data_samples_x_channels) .* factor; end
function data = readRawSoundFile(path, nrCh, nrSamp, startSamp), if ~exist(path, 'file'), error('File does not exist: %s', path); end, fp = fopen(path); if fp == -1, error('Cannot open file: %s', path); end, status = fseek(fp, 4*nrCh*startSamp, 'bof'); if status~=0, warning('Could not seek. Reading from beginning.'); fseek(fp, 0, 'bof'); end, [data, count] = fread(fp, [nrCh, nrSamp], 'int32=>double'); actual = count/nrCh; if isinf(nrSamp), fprintf(' Read %d samples/ch.\n', actual); elseif count~=nrCh*nrSamp, warning('Read %d samples, expected %d.', actual, nrSamp); end, fclose(fp); end

% --- Spectrogram and Utilities ---
% --- Spectrogram and Utilities ---
% --- Spectrogram and Utilities ---
function [regionsData, b_band, a_band] = plotSpectrogramSegment(data, fs, tStart, tEnd, f1, f2)
     % ... (initial part of the function is unchanged - setup, sanitization, spectrogram calc) ...
     fprintf('  Generating spectrogram [%.2f, %.2f]s, [%.0f, %.0f]Hz...\n', tStart, tEnd, f1, f2);
     meanData = mean(data, 2)'; idx1 = max(1, round(tStart * fs) + 1);
     idx2 = min(length(meanData), round(tEnd * fs));
     if idx1 >= length(meanData) || idx1 >= idx2, error('Spectrogram segment start time (%.2fs) results in empty or invalid segment.', tStart); end
     segment = meanData(idx1:idx2);
     if isempty(segment), error('Spectrogram segment empty for time range [%.2f, %.2f]s.', tStart, tEnd); end
     if any(~isfinite(segment)), warning('Non-finite values (NaN/Inf) found in segment data. Replacing with 0.'); segment(~isfinite(segment)) = 0; end
     if all(segment == 0), warning('Segment data is all zeros.'); end
     winLen_target = 2 * round(fs / 50 / 2); winLen = min(winLen_target, floor(length(segment)/2)); winLen = max(winLen, 128); overlap = round(0.75*winLen); nfft = max(winLen, 1024);
      if length(segment) < 2 || winLen <= 0 || winLen >= length(segment)
          warning('Segment length (%d) too short for calculated window size (%d). Adjusting or cannot compute.', length(segment), winLen);
          winLen = floor(length(segment) * 0.8); winLen = max(winLen, 32); overlap = round(0.5 * winLen); nfft = max(winLen, 256);
          if length(segment) < 2 || winLen <= 0, error('Cannot generate spectrogram, segment extremely short (%d samples)', length(segment)); end
          fprintf('  Adjusted Spec Params: Win=%d, Overlap=%d, NFFT=%d\n', winLen, overlap, nfft);
      else, fprintf('  Spec Params: Win=%d, Overlap=%d, NFFT=%d\n', winLen, overlap, nfft); end
     [S_spec, f_spec, t_spec, ps] = spectrogram(segment, hann(winLen), overlap, nfft, fs, 'yaxis');
     t_spec = t_spec + tStart; ps_dB = 10*log10(abs(ps)+eps);
     if all(isinf(ps_dB(:))), warning('Spectrogram resulted in all -Inf dB values (likely zero input). Plot might be blank.'); end

     % --- Create Figure and Plot ---
     figSpec = figure('Name', 'Spectrogram - Draw Regions & Press Enter', 'Position', get(0,'Screensize').*[0.1 0.1 0.8 0.7]);
     imagesc(t_spec, f_spec, ps_dB); axis xy;
     ylim_actual = [max(min(f_spec), f1), min(max(f_spec),f2)];
     if ylim_actual(1) >= ylim_actual(2), ylim_actual = [min(f_spec), max(f_spec)]; end
     if ~isempty(ylim_actual) && all(isfinite(ylim_actual)), ylim(ylim_actual); else, warning('Could not determine valid Y limits for spectrogram.'); end
     clim('auto'); colormap(gca, 'hot'); colorbar; ylabel('Freq (Hz)'); xlabel('Time (s)');
     title({'Select Time-Frequency Region(s) with Rectangle Tool,', 'Click INSIDE FIGURE then Press ENTER to accept selection'}); % Emphasize click

    % --- ROI Selection Logic ---
     regionsData = []; roiHandles = []; isDone = false;

     % <<< --- MODIFICATION HERE --- >>>
     % Explicitly add uiresume in the KeyPressFcn
     figSpec.KeyPressFcn = @(src, evt) KeyPressedInFigure(src, evt);
     % --- End Modification ---

     % Local function for KeyPress handling
     function KeyPressedInFigure(src, evt)
          fprintf('--- Key Pressed: %s ---\n', evt.Key); % DEBUGGING Line
          set(src, 'UserData', evt.Key); % Store the key that was pressed
          uiresume(src); % Explicitly resume execution!
     end

     while ~isDone
         try
             % Add a reminder in the loop start
             fprintf('Waiting for ROI drawing or key press (Click IN FIGURE WINDOW first!)...\n');

             h = drawrectangle('Color','cyan', 'LineWidth', 1.5, 'FaceAlpha', 0.1);
             if ~isvalid(h)
                 warning('Spectrogram figure closed prematurely or drawing cancelled?');
                 isDone = true; break;
             end
             roiHandles = [roiHandles, h];

             % Wait for interaction (KeyPressFcn will trigger uiresume)
             customWait(figSpec); % This call now waits until uiresume is called

             key = get(figSpec,'UserData');
             % Check if UserData was actually set (might not be if uiwait ended some other way)
             if isempty(key)
                 fprintf('uiwait finished without key press recorded.\n');
                 % Check if figure still exists, maybe it was closed manually
                 if ~ishandle(figSpec)
                     warning('Figure closed manually during wait.');
                     isDone = true; % Treat as cancellation
                     regionsData = []; % No regions
                     delete(roiHandles); roiHandles = [];
                 end
                 % Loop might continue if figure still exists but wait ended unexpectedly
                 continue; % Skip to next iteration or re-wait
             end

              fprintf('... Key "%s" detected after wait.\n', key); % Confirm detection

             % Check key (use strcmpi for case-insensitivity)
             if strcmpi(key,'return')
                 fprintf('Enter key detected. Finalizing selection.\n');
                 isDone = true;
             elseif strcmpi(key,'escape')
                 disp(' User pressed Escape. No regions will be processed.');
                 regionsData = []; isDone = true; delete(roiHandles); roiHandles = [];
             % Optional: Add deletion of last ROI, e.g., on 'backspace' or 'delete' key
             % elseif strcmpi(key, 'backspace') || strcmpi(key,'delete')
             %    if ~isempty(roiHandles)
             %        fprintf('Deleting last ROI.\n');
             %        delete(roiHandles(end));
             %        roiHandles(end) = [];
             %    end
             else
                   % Any other key was pressed, likely user clicked elsewhere or wants to draw more
                   fprintf(' (Key "%s" ignored or new rectangle %d drawn. Press Enter when done.)\n', key, length(roiHandles));
                   % Loop continues, customWait will pause again after next drawrectangle
             end
         catch ME_draw
             fprintf('*** CATCH BLOCK REACHED in draw loop ***\n'); % DEBUG
             if contains(ME_draw.message, 'destroyed') || ~ishandle(figSpec)
                  warning('Spectrogram figure closed or destroyed during selection.'); isDone = true;
             else, disp('Error during ROI drawing/waiting: %s', ME_draw.message); end
              % Clean up potentially dangling handles
              if ~isempty(roiHandles), delete(roiHandles(isvalid(roiHandles))); roiHandles = []; end
             isDone = true; % Force exit loop on error
         end
     end % End while ~isDone


    % --- Collect ROI data ---
     validRegions = 0; tempRegionsData = {};
     % Make sure roiHandles still exist and are valid if loop exited abnormally
     if ~isempty(roiHandles)
        validHandles = roiHandles(isvalid(roiHandles)); % Get only handles that are still good
        for i=1:length(validHandles)
            h = validHandles(i);
             pos = h.Position;
             if pos(3) > 1e-6 && pos(4) > 1e-6 % Check positive width/height
                 tempRegionsData{end+1} = struct('t_start',pos(1),'t_end',pos(1)+pos(3),'f_min',pos(2),'f_max',pos(2)+pos(4));
                 validRegions = validRegions + 1;
             end
             delete(h); % Delete handle after getting data or if invalid
         end
     end
     if ~isempty(tempRegionsData), regionsData = cat(1, tempRegionsData{:}); else, regionsData = []; end % Convert cell to struct array
     fprintf(' Spectrogram: User selected %d valid region(s).\n', validRegions);


    % --- Close the figure ---
     if ishandle(figSpec)
         fprintf(' Closing spectrogram window...\n');
         close(figSpec); drawnow;
     end

     b_band=[]; a_band=[];

     function customWait(hFig) % Helper sub-function
        set(hFig,'UserData',''); % Clear previous user data/key press before waiting
        try
             % fprintf('--- Entering uiwait ---\n'); % DEBUG Line
             uiwait(hFig); % This now RELIES on KeyPressedInFigure calling uiresume
             % fprintf('--- Exited uiwait ---\n');  % DEBUG Line
        catch ME_wait
            if contains(ME_wait.message,'destroyed') || ~ishandle(hFig)
                warning('Figure closed while waiting for input in customWait.');
            else, rethrow(ME_wait); end
        end
     end % End customWait

end % End of plotSpectrogramSegment function

function [mask, threshold] = adaptive_threshold_detection(map)
    % Normalizes map to [0, 1] range and applies threshold (Otsu or median).
    threshold = NaN; % Default output in case of error
    mask = false(size(map)); % Default output

    try
        % --- Input Validation ---
        if ~isnumeric(map) || ~ismatrix(map)
            warning('Adaptive thresholding: Input map is not a valid 2D numeric matrix.');
            return; % Return defaults
        end
        map(isinf(map)) = NaN; % Replace Inf with NaN
        if all(isnan(map(:)))
             warning('Adaptive thresholding: Input map contains only NaNs.');
             return; % Return defaults
        end
        % Find min/max ignoring NaNs
         % --- CORRECTED min/max SYNTAX ---
        map_min = min(map(:), [], 'omitnan');
        map_max = max(map(:), [], 'omitnan');
        % --- END CORRECTION ---
        map_range = map_max - map_min;

        % Handle edge case of a constant or near-constant map (or all NaN)
        if isnan(map_range) || map_range < eps
            % warning('Adaptive thresholding: Input map is constant or contains only NaNs.');
            threshold = map_max + 1; % Set threshold above max -> no detection
            mask = false(size(map));
            return;
        end

        % Normalize map to [0, 1], handling potential NaNs
        map_norm = (map - map_min) ./ map_range;
        map_norm(isnan(map_norm)) = 0; % Set NaNs to 0 after normalization

        % Calculate threshold on the normalized map
        threshold_norm = 0.5; % Default fallback
        if license('test','image_toolbox') && exist('graythresh','file')
            try
                % graythresh works on finite values
                 map_norm_finite = map_norm(isfinite(map_norm)); % Already handled NaNs/Infs
                 % Check if there's any variation for graythresh to work on
                 if ~isempty(map_norm_finite) && max(map_norm_finite) > min(map_norm_finite) + eps % Check range
                     threshold_norm = graythresh(map_norm_finite); % Use finite values
                 else
                     warning('graythresh input has no variation. Using 0.5.');
                 end
            catch ME_gray
                 disp('graythresh failed: %s. Using 0.5.', ME_gray.message);
            end
        end

        % Scale threshold back to original map range
        threshold = threshold_norm * map_range + map_min;

        % Final check: Ensure threshold is scalar and finite
        if ~isscalar(threshold) || ~isfinite(threshold)
             warning('Adaptive threshold calc resulted in non-scalar/non-finite value. Using NaN.');
             threshold = NaN;
             mask = false(size(map));
             return;
        end

        % Apply threshold to the original map (ignoring NaNs in comparison)
        mask = map > threshold;
        mask(isnan(map)) = false; % Ensure NaNs in map don't become true in mask

    catch ME_adapt
        % --- CORRECTED disp TO fprintf ---
        fprintf('Error in adaptive_threshold_detection: %s. Returning NaN threshold.\n', ME_adapt.message);
        % --- END CORRECTION ---
        threshold = NaN; % Ensure NaN on error
        mask = false(size(map));
    end
end

function analyze_matrix_condition(H, freq) % Simplified
    global G_curr_condition G_curr_svd_s; [m, n] = size(H); fprintf(' Matrix (%dx%d) ',m,n); if m==0||n==0, return; end; try cond_num = cond(double(H)); catch, cond_num=NaN; end; fprintf('Cond=%.2e ', cond_num); G_curr_condition=cond_num; try [~,S,~]=svd(double(H),'econ'); G_curr_svd_s=diag(S); fprintf(' %d SVs. ',length(G_curr_svd_s)); catch, G_curr_svd_s=[]; end; fprintf('\n');
end

% --- Solver Functions ---
function [z, info] = tsvd_reconstruction(G, p, k_abs, k_ratio, alpha) % Simplified
    [U,S,V]=svd(double(G),'econ'); s=diag(S); Nsv=length(s); if isnan(k_abs), k=max(1,min(Nsv,round(k_ratio*Nsv))); else k=max(1,min(Nsv,round(k_abs))); end; s_inv = s(1:k)./(s(1:k).^2+alpha); z=V(:,1:k)*(s_inv .* (U(:,1:k)'*p)); info.k_used=k; info.relative_residual=norm(G*z-p)/norm(p); info.message=sprintf('TSVD OK k=%d',k);
end
% --- Solver Functions ---
% ... (other solvers like tsvd_reconstruction, l1_tv_reconstruction) ...

% --- Modified sparse_bayesian_learning_original with Real-Time Plotting ---
% --- Modified sparse_bayesian_learning_original with History Tracking & Plot Fixes ---
% --- Improved sparse_bayesian_learning_original ---
function [z, dH, rH, iter, info] = sparse_bayesian_learning_original(G, p, maxIter, params)
    fprintf(' -> Entering sparse_bayesian_learning_original...\n');
    [M, N] = size(G);
    info = struct('message','Init', 'termination_reason','Init', 'iterations', 0, 'relative_residual', NaN, 'final_beta', NaN, 'final_alpha', []); % Default Info
    z = zeros(N,1); dH = []; rH = []; iter = 0; % Default outputs

    if M == 0 || N == 0, error('SBL Input matrix G is empty.'); end
    if isempty(p) || size(p,1) ~= M, error('SBL Input vector p size mismatch.'); end
    p = double(p); G = double(G); % Ensure double precision internally
    norm_p = norm(p); if norm_p < eps, warning('SBL: Input vector p is near zero.'); info.message='Zero input p'; info.relative_residual=0; return; end
    ETA = eps; % Use machine epsilon for double

    % Initialize parameters
    alpha = ones(N,1); beta = 1 / (var(p)/10 + ETA); z = zeros(N,1); keep = (1:N)';

    % Update default info message now that inputs are valid
    info.message='Max Iter Reached'; info.termination_reason='Max Iter'; info.iterations = maxIter;

    % Get Parameters & Check for Plotting/Tracking
    stop_criterion = params.sbl_stop_criterion; tol_alpha = params.esm_sbl_tolerance_alpha;
    tol_z = params.sbl_stop_tolerance_z; tol_res = params.sbl_stop_tolerance_res;
    patience = params.sbl_stop_patience; do_plot = params.esm_sbl_plot;
    track_hist = params.esm_sbl_track; plot_interval = params.sbl_plot_interval;

    fprintf('    SBL Start: N=%d sources, M=%d sensors. Stop=%s, MaxIter=%d. Plot=%d, Track=%d\n', N, M, stop_criterion, maxIter, do_plot, track_hist);

    % Initialize History Arrays
    if track_hist, iter_history = zeros(1, maxIter); rel_res_history = zeros(1, maxIter); active_count_history = zeros(1, maxIter); alpha_change_history = nan(1, maxIter); end
    dH = []; rH = []; % Always init

    % Initialize Plotting Figure (if requested)
    hFigSBL = []; hAxSBL = gobjects(4,1); hPlotSBL = gobjects(3,1); hTextSBL = [];
    if do_plot
        figNumSBL = 110; if ishandle(figNumSBL), clf(figNumSBL); else, figure(figNumSBL); end
        hFigSBL = figure(figNumSBL); set(hFigSBL, 'Name', 'SBL Convergence', 'NumberTitle', 'off', 'Position', [100, 100, 800, 600]);
        hAxSBL(1) = subplot(2,2,1); title('Relative Residual'); xlabel('Iteration'); ylabel('||p - Gz|| / ||p||'); grid on; set(gca, 'YScale', 'log'); hold on;
        hAxSBL(2) = subplot(2,2,2); title('Number of Active Sources'); xlabel('Iteration'); ylabel('Count'); grid on; hold on;
        hAxSBL(3) = subplot(2,2,3); title('Norm Change in Alpha'); xlabel('Iteration'); ylabel('||a_k - a_{k-1}|| / ||a_{k-1}||'); grid on; set(gca, 'YScale', 'log'); hold on;
        hAxSBL(4) = subplot(2,2,4); axis off; hTextSBL = text(0.05, 0.5, 'Starting...', 'VerticalAlignment', 'middle', 'FontSize', 9); title('Status');
        hPlotSBL(1) = plot(hAxSBL(1), NaN, NaN, 'b.-'); hPlotSBL(2) = plot(hAxSBL(2), NaN, NaN, 'r.-'); hPlotSBL(3) = plot(hAxSBL(3), NaN, NaN, 'g.-');
        sgtitle(hFigSBL, 'SBL Solver Convergence Progress'); drawnow; % Draw initial empty plot
    end

    % SBL Iteration Loop
    z_old = z; res_old_norm = Inf; patience_counter = 0; active_set_stable = false; converged = false; keep_old = keep; alpha_old_active = alpha(keep);
    iter_count = 0;

    for iter = 1:maxIter
        iter_count = iter;
        if isempty(keep), warning('SBL: Active set empty iter %d.', iter); info.message = 'Active Set Empty'; info.termination_reason = 'Empty Set'; z = zeros(N,1); converged = true; break; end

        % --- E-Step ---
        alpha_current_active = alpha(keep); G_a = G(:, keep);
        A_a = spdiags(alpha_current_active, 0, length(keep), length(keep)); % Use double for diag
        try Sigma_a = (beta * (G_a' * G_a) + A_a) \ eye(length(keep)); % More stable inversion using \
        catch ME_chol, warning('SBL Iter %d: Matrix inversion failed: %s. Trying pinv.', iter, ME_chol.message); try Sigma_a = pinv(beta * (G_a' * G_a) + A_a); catch ME_pinv, error('SBL Iter %d: pinv also failed: %s', iter, ME_pinv.message); end; end
        if any(~isfinite(Sigma_a(:))), error('SBL Iter %d: Sigma_a contains NaN/Inf after inversion.', iter); end
        z_a = beta * Sigma_a * (G_a' * p);
        if any(~isfinite(z_a(:))), error('SBL Iter %d: z_a contains NaN/Inf.', iter); end
        z(:) = 0; z(keep) = z_a;

        % --- M-Step ---
        try diag_Sigma_a = diag(Sigma_a); diag_Sigma_a(diag_Sigma_a < 0) = 0; gamma = max(0, 1 - alpha_current_active .* real(diag_Sigma_a)); catch ME_diag, error('SBL Iter %d: Error diag(Sigma_a): %s', iter, ME_diag.message); end
        if any(~isfinite(gamma(:))), error('SBL Iter %d: gamma contains NaN/Inf.', iter); end
        alpha_new_active = gamma ./ (abs(z_a).^2 + ETA);
        if any(~isfinite(alpha_new_active(:))), warning('SBL Iter %d: alpha_new_active contains NaN/Inf. Problematic update.', iter); alpha_new_active(~isfinite(alpha_new_active)) = 1e12; end % Reset unstable alphas
        alpha(keep) = alpha_new_active;
        residual = p - G_a * z_a; res_sq_norm = norm(residual)^2;
        if ~isfinite(res_sq_norm), error('SBL Iter %d: Residual norm^2 non-finite.', iter); end
        beta_new = max(ETA, (M - sum(gamma)) / (res_sq_norm + ETA));
        if ~isfinite(beta_new), error('SBL Iter %d: beta_new non-finite.', iter); end
        beta = beta_new;

        % --- Pruning ---
        prune_threshold = 1e12; prune_indices_in_keep = find(alpha(keep) >= prune_threshold); % Check updated alpha
        if ~isempty(prune_indices_in_keep), keep(prune_indices_in_keep) = []; end
        keep_new = keep;

        % --- Calculate Metrics ---
        delta_alpha_norm = NaN; % Default if cannot compare
        if iter > 1 && ~isempty(keep) && ~isempty(keep_old)
             % Find intersection and map indices
             [common_indices, ia, ib] = intersect(keep, keep_old);
             if ~isempty(common_indices)
                 alpha_now_common = alpha(keep(ia));
                 alpha_old_common = alpha_old_active(ib); % Get corresponding old alphas
                 delta_alpha = alpha_now_common - alpha_old_common;
                 norm_alpha_old_common = norm(alpha_old_common);
                 if norm_alpha_old_common > ETA
                    delta_alpha_norm = norm(delta_alpha) / norm_alpha_old_common;
                 else, delta_alpha_norm = norm(delta_alpha); end % Avoid division by zero
             end
        end
        delta_z_norm = norm(z - z_old) / (norm(z_old) + ETA);
        res_norm = norm(residual); delta_res_norm = abs(res_norm - res_old_norm) / (res_old_norm + ETA);
        relative_residual = res_norm / norm_p;
        current_active_count = length(keep);

        % --- Append to History ---
        if track_hist
            iter_history(iter) = iter; rel_res_history(iter) = relative_residual; active_count_history(iter) = current_active_count; alpha_change_history(iter) = delta_alpha_norm;
            dH = [dH; delta_alpha_norm]; rH = [rH; relative_residual];
        end

        % Evaluate active set stability
        if iter > 1 && isequal(keep_new, keep_old), patience_counter = patience_counter + 1; if patience_counter >= patience, active_set_stable = true; end; else patience_counter = 0; active_set_stable = false; end

        % --- Update Plot ---
        if do_plot && (mod(iter, plot_interval) == 0 || iter == 1 || iter == maxIter) && ishandle(hFigSBL)
         try
             figure(hFigSBL); % <<< ADD THIS LINE to ensure focus
             iters_so_far = iter_history(1:iter);
             set(hPlotSBL(1), 'XData', iters_so_far, 'YData', rel_res_history(1:iter));
             set(hPlotSBL(2), 'XData', iters_so_far, 'YData', active_count_history(1:iter));
             if iter > 1, set(hPlotSBL(3), 'XData', iters_so_far(2:iter), 'YData', alpha_change_history(2:iter)); end
             for ax_idx = 1:3, axis(hAxSBL(ax_idx),'tight'); yl = ylim(hAxSBL(ax_idx)); if yl(1)<=0 && strcmp(get(hAxSBL(ax_idx),'YScale'),'log'), ylim(hAxSBL(ax_idx),[min(ylim(hAxSBL(ax_idx)))*0.1+eps, yl(2)]); end; end % Adjust log plot limits
             status_text = sprintf('Iter: %d/%d\nRelRes: %.4f\nActive: %d\nDeltaAlpha: %.2e', iter, maxIter, relative_residual, current_active_count, delta_alpha_norm);
             set(hTextSBL, 'String', status_text);
             drawnow; % Changed from limitrate to drawnow
         catch ME_plot, warning('SBL Plotting error iter %d: %s', iter, ME_plot.message); 
         end
        end

        % --- Apply Stopping Criteria ---
        stop_now = false; reason = ''; current_delta_alpha = alpha_change_history(iter); if isnan(current_delta_alpha), current_delta_alpha = inf; end
        switch lower(stop_criterion)
            case 'alpha', if current_delta_alpha < tol_alpha, stop_now = true; reason = sprintf('Alpha < %.1e', tol_alpha); end
            case 'solution', if delta_z_norm < tol_z, stop_now = true; reason = sprintf('Sol < %.1e', tol_z); end
            case 'residual', if delta_res_norm < tol_res, stop_now = true; reason = sprintf('Res < %.1e', tol_res); end
            case 'active_set', if active_set_stable, stop_now = true; reason = sprintf('ActStable(%d)', patience); end
            case 'combined', alpha_converged = current_delta_alpha < tol_alpha; sol_converged = delta_z_norm < tol_z; res_converged = delta_res_norm < tol_res; if alpha_converged && (sol_converged || res_converged || active_set_stable), stop_now = true; reason = sprintf('Comb: A<%.1e+(S<%.1e|R<%.1e|AS(%d))', tol_alpha, tol_z, tol_res, patience*active_set_stable); end
            otherwise, stop_criterion = 'alpha'; if current_delta_alpha < tol_alpha, stop_now = true; reason = sprintf('Alpha < %.1e', tol_alpha); end
        end
        if stop_now, fprintf('    SBL Converged at Iter %d. Reason: %s\n', iter, reason); info.message = sprintf('SBL Conv (%s)', reason); info.termination_reason = reason; converged = true; break; end

        % Prepare for next iteration
        z_old = z; res_old_norm = res_norm; keep_old = keep_new;
        alpha_old_active = alpha(keep_old); % Store alpha values for next comparison (only for active set)
        if mod(iter, 50) == 0, fprintf('    SBL Iter %d: RelRes=%.4f, Act=%d\n', iter, relative_residual, current_active_count); end

    end % End of SBL Iteration Loop

    if ~converged, fprintf('    SBL WARNING: Reached Max Iter (%d).\n', maxIter); end

    % --- Final Plot Update ---
     if do_plot && ishandle(hFigSBL)
         try % Final update might fail if history is bad
             final_relative_residual = rel_res_history(iter_count); % Use last calculated value
             final_active_count = active_count_history(iter_count);
             status_text = sprintf('FINISHED - Iter: %d\nReason: %s\nFinal RelRes: %.4f\nFinal Active: %d', iter_count, info.termination_reason, final_relative_residual, final_active_count);
             set(hTextSBL, 'String', status_text);
             % Update plot lines with final history
             set(hPlotSBL(1), 'XData', iter_history(1:iter_count), 'YData', rel_res_history(1:iter_count));
             set(hPlotSBL(2), 'XData', iter_history(1:iter_count), 'YData', active_count_history(1:iter_count));
             if iter_count > 1, valid_alpha_idx = find(~isnan(alpha_change_history(2:iter_count)) & isfinite(alpha_change_history(2:iter_count))); set(hPlotSBL(3), 'XData', iter_history(valid_alpha_idx+1), 'YData', alpha_change_history(valid_alpha_idx+1)); else set(hPlotSBL(3), 'XData', NaN, 'YData', NaN); end
             for ax_idx = 1:3, axis(hAxSBL(ax_idx),'tight'); yl = ylim(hAxSBL(ax_idx)); if yl(1)<=0 && strcmp(get(hAxSBL(ax_idx),'YScale'),'log'), ylim(hAxSBL(ax_idx),[min(ylim(hAxSBL(ax_idx)))*0.1+eps, yl(2)]); end; end % Adjust log plot limits
             drawnow;
         catch ME_plot_final, disp('SBL Final Plotting update error: %s', ME_plot_final.message); end
     end

    % Store final results in info struct
    info.iterations = iter_count; info.final_beta = beta; info.final_alpha = alpha;
    % Ensure final residual is stored correctly
    if track_hist && iter_count > 0, info.relative_residual = rel_res_history(iter_count); elseif ~isempty(residual), info.relative_residual = norm(residual)/norm_p; else, info.relative_residual = NaN; end % Calculate if not tracked
    fprintf(' -> Exiting sparse_bayesian_learning_original. RelRes=%.4f, Iter=%d\n', info.relative_residual, info.iterations);

end % End function sparse_bayesian_learning_original
    

% --- General Helpers ---
function val = iif(cond, tv, fv), if cond, val = tv; else val = fv; end, end
function hash_str = simple_hash(input_struct) % Simple hash for caching
    persistent hasher; if isempty(hasher), try hasher = System.Security.Cryptography.SHA256Managed; catch, hasher=[]; end; end
    str = getByteStreamFromArray(input_struct);
    if ~isempty(hasher), hash_bytes = hasher.ComputeHash(str); hash_str = lower(sprintf('%2.2x', hash_bytes)); else hash_str = num2str(sum(double(str))); end % Fallback if .NET fails
end

% --- k-Wave Propagator Function & Helpers ---


function [H_data, cache_hit] = compute_H_kwave(receiver_points, source_points, omega, layer_info, kwave_params)
    % Computes Green's function matrix H using k-Wave simulations with caching.
    % Incorporates FFT on GPU optimization.
    % Removed invalid 'clear' from parfor loop.

    % --- Initial definitions ---
    f = omega / (2*pi);
    if isempty(receiver_points) || size(receiver_points,2) ~= 3, error('compute_H_kwave: Invalid receiver_points.'); end
    if isempty(source_points) || size(source_points,2) ~= 3, error('compute_H_kwave: Invalid source_points.'); end
    N_receiver = size(receiver_points, 1); N_source = size(source_points, 1);

    cache_hit = false; H_data = struct('H',[], 'deleteIndexesSrc',[], 'N_src_valid',0);

    % --- Create Cache Filename & Check Cache ---
    gpu_tag = iif(kwave_params.kwave_gpu_available_and_selected, '_GPU', '_CPU');
    % Simplify cache struct slightly for robustness, remove nested params
    cache_id_struct = struct('receivers', receiver_points, 'sources', source_points, ...
                             'omega', omega, 'layer', layer_info, ...
                             'ppw', kwave_params.ppw, 'CFL', kwave_params.CFL, ...
                             't_end_f', kwave_params.t_end_factor, 'pml', kwave_params.pml_size, ...
                             'gpu_used', kwave_params.kwave_gpu_available_and_selected);
    cache_hash = simple_hash(cache_id_struct);
    cache_filename = fullfile(kwave_params.cache_dir, sprintf('H_%s_%s_f%.2fHz_%s%s.mat', kwave_params.caller_id, layer_info.medium_type, f, cache_hash, gpu_tag));

    if exist(cache_filename, 'file') && ~kwave_params.force_recompute
        fprintf('   k-Wave H (%s, %s): Found cache file: %s. Loading...\n', kwave_params.caller_id, upper(strrep(gpu_tag,'_','')), cache_filename); tic;
        try
            load(cache_filename, 'H_data_cached');
            if ~isfield(H_data_cached,'H') || ~isfield(H_data_cached,'N_src_valid'), warning('Cached data incomplete. Recomputing...');
            else H_data = H_data_cached; cache_hit = true; fprintf('   Loaded from cache in %.2f s. (Valid sources: %d)\n', toc, H_data.N_src_valid); return; end
        catch ME_load, warning('Failed load/validate k-Wave cache file %s: %s. Recomputing...', cache_filename, ME_load.message); end
    end

    % --- CACHE MISS: Proceed with k-Wave computation ---
    fprintf('--- Computing Propagator H (%dx%d) using k-Wave (f=%.2f Hz) for %s (%s) ---\n', N_receiver, N_source, f, kwave_params.caller_id, upper(strrep(gpu_tag,'_','')));
    H = complex(zeros(N_receiver, N_source)); deleteIndexesSrc = [];

    % --- Setup k-Wave Grid and Medium ---
    fprintf('   Setting up k-Wave grid and medium...\n');
    kgrid = []; % Initialize kgrid variable to ensure it exists
    kwave_medium = []; grid_info = []; % Initialize outputs
    try
        % Call the helper function
        [kgrid_temp, kwave_medium_temp, grid_info_temp] = setup_kwave_grid_medium(receiver_points, source_points, omega, layer_info, kwave_params);

        % <<< --- Rigorous Validation of setup_kwave_grid_medium Output --- >>>
        if isempty(kgrid_temp) || ~isa(kgrid_temp, 'kWaveGrid')
             error('setup_kwave_grid_medium did not return a valid kWaveGrid object. Returned class: %s', class(kgrid_temp));
        end
        % Check essential properties needed LATER (after sensor definition)
        props_needed_later = {'t_array', 'dt', 'Nt'};
        for p_idx = 1:length(props_needed_later)
            prop_name = props_needed_later{p_idx};
             if ~isprop(kgrid_temp, prop_name) || isempty(kgrid_temp.(prop_name))
                 error('Returned kgrid object is missing or has empty essential property: %s', prop_name);
             end
        end
        % Check properties needed NOW for define_kwave_sensor
        props_needed_now = {'Nx','Ny','Nz','x_vec','y_vec','z_vec'};
         for p_idx = 1:length(props_needed_now)
            prop_name = props_needed_now{p_idx};
             if ~isprop(kgrid_temp, prop_name) || isempty(kgrid_temp.(prop_name))
                 error('Returned kgrid object is missing or has empty property needed for sensor def: %s', prop_name);
             end
         end

        % Assign to main variables IF validation passes
        kgrid = kgrid_temp;
        kwave_medium = kwave_medium_temp;
        grid_info = grid_info_temp;
        fprintf('   ... k-Wave grid setup validation passed. Class: %s, Size: %dx%dx%d\n', class(kgrid), kgrid.Nx, kgrid.Ny, kgrid.Nz);
        % <<< --- End Validation --- >>>

    catch ME_setup
        error('Fatal error during setup_kwave_grid_medium call or validation: %s\n Occurred in %s at line %d', ME_setup.message, ME_setup.stack(1).name, ME_setup.stack(1).line);
    end

    % <<< --- Explicit Check Before Use --- >>>
    if isempty(kgrid) || ~isa(kgrid, 'kWaveGrid')
        error('CRITICAL INTERNAL ERROR: kgrid variable is invalid or empty AFTER setup block.');
    end
    fprintf('   DEBUG: Proceeding to define sensor mask. kgrid is class %s.\n', class(kgrid));
    % <<< --- End Explicit Check --- >>>

    % --- Define Sensor Mask ---
    fprintf('   Defining sensor mask...\n');
    [sensor, sensor_mapping_info] = define_kwave_sensor(kgrid, receiver_points); % Uses validated kgrid

    if sensor_mapping_info.num_sensors_mapped == 0
        error('No receiver points mapped to k-Wave grid sensor mask!');
    end

    % --- Define Source Signal ---
    fprintf('   Defining source signal...\n');
    source_amp = 1;
    t_array_local = kgrid.t_array;
    source_signal_tone = source_amp * sin(omega * t_array_local);
    try % Define Tukey Window
        if ~license('test','Signal_Toolbox'), error('Signal Processing Toolbox license required for tukeywin.'); end
        tukey_alpha = 0.1;
        tukey_win = tukeywin(kgrid.Nt, tukey_alpha)'; % Ensure row vector
        if isempty(tukey_win) || length(tukey_win) ~= kgrid.Nt, error('Failed creating valid Tukey window.'); end
    catch ME_win, if contains(ME_win.identifier, 'license'), rethrow(ME_win); else, error('Failed creating window: %s.', ME_win.message); end; end
    if ~isrow(source_signal_tone), source_signal_tone = source_signal_tone.'; end % Ensure row
    if ~isrow(tukey_win), tukey_win = tukey_win.'; end % Ensure row
    source_signal = source_signal_tone .* tukey_win; % Element-wise multiplication

    % --- Simulation Options & Loop ---
    kwave_options = {'PMLSize', kwave_params.pml_size, 'PlotSim', false, 'DisplayMask', 'off'};
    data_cast_option = 'single'; sim_env_str = 'CPU';
    if kwave_params.kwave_gpu_available_and_selected
        data_cast_option = 'gpuArray-single';
        sim_env_str = 'GPU';
        fprintf('   Running k-Wave sims on GPU (single).\n');
    else
        fprintf('   Running k-Wave sims on CPU (single).\n');
    end
    kwave_options = [kwave_options, {'DataCast', data_cast_option}];

    t_sim_total = 0;
    parfor_threshold = 16; % Example: Use parfor if more than 16 sources
    % Check if parallel is possible and desired (might be disabled during GA parallel run)
    can_run_parallel = (N_source >= parfor_threshold) && license('test','Parallel_Computing_Toolbox');
    % If GA is already parallelized, don't nest parfor
    pool_active = ~isempty(gcp('nocreate'));
    run_parallel = can_run_parallel && ~pool_active; % Only run parfor here if GA isn't already parallel

    if run_parallel
        % --- PARALLEL SIMULATION LOOP ---
        fprintf('   Running simulations in PARALLEL for %d sources...\n', N_source);
        % Preallocate cell array for results to avoid race conditions
        H_cell = cell(1, N_source);
        delIdx_cell = cell(1, N_source);
        sim_times = zeros(1, N_source);

        parfor j = 1:N_source
            fprintf('   Starting k-Wave PAR source %d of %d on %s worker...\n', j, N_source, sim_env_str);
            r_src_par = source_points(j,:);
            % Each worker needs its own source struct instance
            source_j_par = define_kwave_source(kgrid, r_src_par, source_signal); % Uses kgrid broadcast to workers

            H_col_par = complex(zeros(N_receiver, 1)); % Initialize column
            delIdx_par = []; % Initialize deletion index for this worker

            if isempty(source_j_par)
                warning('PAR: Source %d outside grid. Skipping.', j);
                delIdx_par = j;
                H_col_par(:) = NaN;
            else
                try
                    tic_sim_par = tic;
                    sensor_data_j_par = kspaceFirstOrder3D(kgrid, kwave_medium, source_j_par, sensor, kwave_options{:});
                    sim_times(j) = toc(tic_sim_par); % Store time
                    fprintf('    -> PAR Sim %d complete in %.2f s.\n', j, sim_times(j));

                    % --- FFT ON GPU/WORKER ---
                    p_receiver_time_raw = sensor_data_j_par.p; % Keep raw (gpuArray or single)
                    N_fft_par = 2^nextpow2(kgrid.Nt);
                    fft_p_par = fft(p_receiver_time_raw, N_fft_par, 2); % FFT along time dim
                    freq_vec_par = (0:N_fft_par-1) / (N_fft_par * kgrid.dt);
                    [~, idx_omega_par] = min(abs(freq_vec_par - f));

                    p_complex_at_omega_gpu = squeeze(fft_p_par(:, idx_omega_par));
                    p_complex_at_omega = gather(p_complex_at_omega_gpu); % Gather small slice
                    % REMOVED: clear p_complex_at_omega_gpu fft_p_par p_receiver_time_raw;

                    scaling_factor_par = 2 / sum(double(tukey_win)); % Use double for sum
                    p_complex_scaled = double(p_complex_at_omega) * scaling_factor_par / source_amp;
                    H_col_ordered_par = map_grid_to_points(p_complex_scaled, sensor.mask, receiver_points, kgrid);
                    H_col_par = H_col_ordered_par;
                    % --- END FFT ON GPU/WORKER ---

                catch ME_par
                    warning('PAR: k-Wave simulation failed for source %d: %s', j, ME_par.message);
                    if isa(kwave_medium,'gpuArray') && contains(lower(ME_par.message),'out of memory'), warning('PAR: GPU out of memory on worker?'); end
                    delIdx_par = j; H_col_par(:) = NaN;
                end % End try-catch parfor sim
            end % End if isempty(source_j_par)

            % Store results from this worker
            H_cell{j} = H_col_par;
            delIdx_cell{j} = delIdx_par;

        end % End parfor loop

        % Consolidate results after parfor loop
        H = horzcat(H_cell{:});
        deleteIndexesSrc = vertcat(delIdx_cell{:});
        t_sim_total = sum(sim_times); % Sum of individual times
        fprintf('   Total parallel k-Wave simulation time (sum of worker times): %.2f s\n', t_sim_total);

    else % --- SEQUENTIAL SIMULATION LOOP ---
        if pool_active
             fprintf('   Running simulations SEQUENTIALLY for %d sources (GA is parallel)...\n', N_source);
        else
             fprintf('   Running simulations SEQUENTIALLY for %d sources (Parallel disabled or N < %d)...\n', N_source, parfor_threshold);
        end

        for j = 1:N_source
            fprintf('   Simulating k-Wave source %d of %d on %s...\n', j, N_source, sim_env_str);
            r_src = source_points(j,:);
            source_j = define_kwave_source(kgrid, r_src, source_signal); % Use validated kgrid

            if isempty(source_j)
                warning('SEQ: Source %d outside grid. Skipping.', j);
                deleteIndexesSrc = [deleteIndexesSrc; j]; H(:, j) = NaN; continue;
            end

            try
                tic_sim = tic;
                sensor_data_j = kspaceFirstOrder3D(kgrid, kwave_medium, source_j, sensor, kwave_options{:});
                t_sim_loop = toc(tic_sim); t_sim_total = t_sim_total + t_sim_loop;
                fprintf('    -> Seq Sim %d complete in %.2f s.\n', j, t_sim_loop);

                % --- FFT ON GPU/CPU (as appropriate) ---
                p_receiver_time_raw = sensor_data_j.p; % Keep raw (gpuArray or single)
                N_fft = 2^nextpow2(kgrid.Nt);
                fft_p = fft(p_receiver_time_raw, N_fft, 2); % FFT along time dim
                freq_vec = (0:N_fft-1) / (N_fft * kgrid.dt);
                [~, idx_omega] = min(abs(freq_vec - f));

                p_complex_at_omega_gpu = squeeze(fft_p(:, idx_omega));
                p_complex_at_omega = gather(p_complex_at_omega_gpu); % Gather small slice
                clear p_complex_at_omega_gpu fft_p p_receiver_time_raw; % Clear intermediate CPU/GPU vars

                scaling_factor = 2 / sum(double(tukey_win)); % Use double for sum
                p_complex_scaled = double(p_complex_at_omega) * scaling_factor / source_amp;
                H_col_ordered = map_grid_to_points(p_complex_scaled, sensor.mask, receiver_points, kgrid); % Use validated kgrid
                H(:, j) = H_col_ordered;
                % --- END FFT ON GPU/CPU ---

            catch ME
                warning('SEQ: k-Wave simulation failed for source %d: %s', j, ME.message); fprintf('   Error in %s line %d.\n', ME.stack(1).name, ME.stack(1).line);
                 if isa(kwave_medium,'gpuArray') && contains(lower(ME.message),'out of memory'), warning('GPU out of memory?'); end
                deleteIndexesSrc = [deleteIndexesSrc; j]; H(:, j) = NaN;
            end % End try-catch sequential sim
        end % End sequential loop
        fprintf('   Total sequential k-Wave simulation time: %.2f s\n', t_sim_total);
    end % End if run_parallel

    % --- Final cleanup and package results ---
    valid_cols = setdiff(1:N_source, deleteIndexesSrc);
    if isempty(valid_cols)
        warning('All k-Wave simulations failed or sources were outside grid.');
        H_data.H = []; H_data.deleteIndexesSrc = (1:N_source)'; H_data.N_src_valid = 0;
    else
        H_data.H = H(:, valid_cols);
        H_data.deleteIndexesSrc = deleteIndexesSrc;
        H_data.N_src_valid = length(valid_cols);
        if any(isnan(H_data.H(:)))
             warning('NaN values found in computed H matrix after processing.');
        end
    end

     % --- Save to Cache ---
     try
         H_data_cached = H_data; % Assign final data to the variable name expected by load
         save(cache_filename, 'H_data_cached', '-v7.3');
         fprintf('   k-Wave H saved to cache: %s\n', cache_filename);
     catch ME_save
         warning('Failed save k-Wave cache file %s: %s', cache_filename, ME_save.message);
     end
     fprintf('--- Finished k-Wave H computation (%s). Valid sources: %d ---\n', upper(strrep(gpu_tag,'_','')), H_data.N_src_valid);

end % End compute_H_kwave function


% --- Other Required Helper Functions ---
% setup_kwave_grid_medium, define_kwave_medium, define_kwave_sensor,
% define_kwave_source, map_grid_to_points, db2neper, simple_hash, iif
% Need to ensure these are present and correct in the main script file or path.

function [kgrid, medium, grid_info] = setup_kwave_grid_medium(receiver_points, source_points, omega, layer_info, kwave_params)
    % Sets up kgrid and medium struct for k-Wave simulation
    f = omega / (2*pi);

    % Determine physical domain bounds
    all_points = [receiver_points; source_points];
    min_coord = min(all_points, [], 1) - 0.02; % Add buffer
    max_coord = max(all_points, [], 1) + 0.02; % Add buffer
    domain_size = max_coord - min_coord;

    % --- Input validation ---
    if any(domain_size <= 0)
         warning('Calculated domain size is zero or negative in at least one dimension. Check source/receiver points.');
         % Ensure a minimum small size to avoid division by zero later
         domain_size = max(domain_size, [0.01, 0.01, 0.01]); % Minimum 1cm domain
         min_coord = mean(all_points,1) - domain_size/2;
         max_coord = mean(all_points,1) + domain_size/2;
         fprintf('  --> Reset domain size to [%.3f, %.3f, %.3f] centered around points.\n', domain_size);
    end
    if isempty(f) || ~isfinite(f) || f <= 0
        error('Invalid frequency (f=%.2f Hz) for grid calculation.', f);
    end
    % --- End input validation ---

    % Determine grid spacing based on highest frequency and lowest speed
    mat_db = layer_info.db;
    c_min = mat_db.air.c; c_max = mat_db.air.c; % Start with air
    if ~strcmpi(layer_info.medium_type, 'air_only')
        % Check if layer material exists
        if isfield(mat_db, layer_info.layer_material_name)
            mat_layer = mat_db.(layer_info.layer_material_name);
            if isfield(mat_layer, 'c') && mat_layer.c > 0
                 c_min = min(c_min, mat_layer.c);
                 c_max = max(c_max, mat_layer.c);
            else
                 warning('Layer material "%s" missing valid sound speed "c". Using air properties.', layer_info.layer_material_name);
            end
        else
            warning('Layer material "%s" not found in database. Using air properties.', layer_info.layer_material_name);
        end
    end
     if c_min <= 0, error('Minimum sound speed must be positive (c_min=%.2f). Check material properties.', c_min); end

    lambda_min = c_min / f;
    dx_sim = lambda_min / kwave_params.ppw;
    if dx_sim <= 1e-9, error('Calculated grid spacing dx=%.2e is too small or non-positive. Check frequency (%.2f Hz), min speed (%.2f m/s), and ppw (%.2f).', dx_sim, f, c_min, kwave_params.ppw); end

    % Determine grid size (use makeGrid wrapper for convenience)
    % Ensure odd number of points? Sometimes preferred, but kWaveGrid handles even ok.
    Nx = round(domain_size(1) / dx_sim); % round might be better than ceil to avoid excessive size
    Ny = round(domain_size(2) / dx_sim);
    Nz = round(domain_size(3) / dx_sim);

    % Ensure minimum size, e.g., for PML plus some buffer
    min_dim = 2*kwave_params.pml_size + 10; % Min size across core domain + PML
    Nx = max(Nx, min_dim); Ny = max(Ny, min_dim); Nz = max(Nz, min_dim);

    % --- Adjust grid size for FFT efficiency ---
    % Ensure dimensions are even numbers. This often helps k-Wave's internal
    % padding or FFT routines perform better than using odd numbers or numbers
    % with large prime factors (like 26 = 2 * 13).
    % Using ceil ensures we don't make the grid smaller than calculated.
    Nx_orig = Nx; Ny_orig = Ny; Nz_orig = Nz; % Store original for comparison
    Nx = 2 * ceil(Nx / 2);
    Ny = 2 * ceil(Ny / 2);
    Nz = 2 * ceil(Nz / 2);
    if Nx~=Nx_orig || Ny~=Ny_orig || Nz~=Nz_orig
        fprintf('   Adjusted grid dims for FFT (was %dx%dx%d): Now %dx%dx%d\n', Nx_orig, Ny_orig, Nz_orig, Nx, Ny, Nz);
    end
    % --- End FFT Adjustment ---

    % Create kWaveGrid centered at (0,0,0) by default
    fprintf('   Attempting kWaveGrid: Nx=%d, dx=%.4fm, Ny=%d, dy=%.4fm, Nz=%d, dz=%.4fm\n', Nx, dx_sim, Ny, dx_sim, Nz, dx_sim);
    try
        % kWaveGrid constructor might perform further padding internally
        kgrid = kWaveGrid(Nx, dx_sim, Ny, dx_sim, Nz, dx_sim);
    catch ME_grid
        error('Failed to create kWaveGrid object: %s\nCheck calculated Nx/Ny/Nz and dx.', ME_grid.message);
    end
    fprintf('   k-Wave Grid created: %d x %d x %d points (dx=%.3f mm)\n', kgrid.Nx, kgrid.Ny, kgrid.Nz, dx_sim*1000);
    % fprintf('     Grid ranges: X[%.3f, %.3f], Y[%.3f, %.3f], Z[%.3f, %.3f]\n', kgrid.x_vec(1), kgrid.x_vec(end), kgrid.y_vec(1), kgrid.y_vec(end), kgrid.z_vec(1), kgrid.z_vec(end));
    % fprintf('     Physical domain required: X[%.3f, %.3f], Y[%.3f, %.3f], Z[%.3f, %.3f]\n', min_coord(1), max_coord(1), min_coord(2), max_coord(2), min_coord(3), max_coord(3));

    % --- REMOVED ORIGIN SHIFT ---
    % grid_center = [kgrid.x_vec(round(Nx/2)); kgrid.y_vec(round(Ny/2)); kgrid.z_vec(round(Nz/2))];
    % phys_center = (max_coord + min_coord)' / 2;
    % origin_offset = phys_center - grid_center;
    % kgrid.x_vec = kgrid.x_vec + origin_offset(1); % <<< REMOVED >>>
    % kgrid.y_vec = kgrid.y_vec + origin_offset(2); % <<< REMOVED >>>
    % kgrid.z_vec = kgrid.z_vec + origin_offset(3); % <<< REMOVED >>>
    % ---

    % Create Time Array
    t_end_est = kwave_params.t_end_factor * max(domain_size) / c_min;
    % Ensure t_end is finite and positive
    if ~isfinite(t_end_est) || t_end_est <= 0
         warning('Estimated t_end is non-positive or non-finite (%.2e). Using default 1ms.', t_end_est);
         t_end_est = 1e-3;
    end
    try
        kgrid.makeTime(c_max, kwave_params.CFL, t_end_est);

        % <<< --- MODIFICATION IS HERE --- >>>
        % Use kgrid.t_array(end) instead of kgrid.t_end
        if ~isempty(kgrid.t_array)
            actual_t_end = kgrid.t_array(end);
            fprintf('   k-Wave Time: Nt=%d, dt=%.2e s, t_end=%.3f ms\n', kgrid.Nt, kgrid.dt, actual_t_end*1000);
        else
             error('kgrid.makeTime executed but t_array is empty. Cannot proceed.');
        end
        % <<< --- END MODIFICATION --- >>>

    catch ME_time
         error('kgrid.makeTime failed: %s. Check c_max=%.2f, CFL=%.2f, t_end=%.e', ME_time.message, c_max, kwave_params.CFL, t_end_est);
    end
    if kgrid.Nt <= 0
        error('Calculated number of time steps Nt=%d is not positive. Check t_end and dt.', kgrid.Nt);
    end

    % Define Medium Properties on Grid
    medium = define_kwave_medium(kgrid, layer_info); % Use helper

    grid_info.min_coord = min_coord; grid_info.max_coord = max_coord;
    grid_info.c_min = c_min; grid_info.c_max = c_max; grid_info.dx_sim = dx_sim;
end

function medium = define_kwave_medium(kgrid, layer_info)
    % Creates the k-Wave medium struct based on grid and layer_info
    % <<< MODIFIED: Enforce scalar medium.alpha_power >>>
    Nx = kgrid.Nx; Ny = kgrid.Ny; Nz = kgrid.Nz;
    mat_db = layer_info.db;

    % --- Get properties for background/front medium (usually air) ---
    if isfield(mat_db, layer_info.material_air_front_name)
        props_front = mat_db.(layer_info.material_air_front_name);
    else
        warning('Front material "%s" not found. Using default air properties.', layer_info.material_air_front_name);
        props_front = mat_db.air; % Fallback
    end

    % --- Choose a SINGLE alpha_power for the whole simulation ---
    % Default to the front medium's power law exponent.
    if isfield(props_front,'alpha_power') && isscalar(props_front.alpha_power) && isfinite(props_front.alpha_power)
        chosen_alpha_power = props_front.alpha_power;
    else
        chosen_alpha_power = 1.0; % Default if not specified/valid for front medium
        warning('Front medium "%s" missing valid scalar alpha_power. Using %.2f.', props_front.name, chosen_alpha_power);
    end
    fprintf('   Using SCALAR medium.alpha_power = %.2f for entire k-Wave simulation.\n', chosen_alpha_power);
    medium.alpha_power = chosen_alpha_power; % <<< SET SCALAR POWER LAW HERE <<<

    % --- Set background medium properties ---
    medium.sound_speed = ones(Nx, Ny, Nz) * props_front.c;
    medium.density = ones(Nx, Ny, Nz) * props_front.rho;

    % Calculate alpha_coeff for background using the CHOSEN alpha_power
    alpha_coeff_front = db2neper(props_front.alpha_dB_m, props_front.alpha_freq_Hz, medium.alpha_power);
    medium.alpha_coeff = ones(Nx, Ny, Nz) * alpha_coeff_front; % Set default coeff

    % --- Add layer properties if present ---
    if ~strcmpi(layer_info.medium_type, 'air_only') && layer_info.thickness > 1e-9
        layer_material_valid = false;
        % Check layer material exists and has minimum required fields
        if isfield(mat_db, layer_info.layer_material_name)
             props_layer = mat_db.(layer_info.layer_material_name);
             required_fields = {'c','rho','alpha_dB_m','alpha_freq_Hz'};
             if all(isfield(props_layer, required_fields)) && ...
                all(cellfun(@(f) isnumeric(props_layer.(f)) && isscalar(props_layer.(f)) && isfinite(props_layer.(f)), required_fields)) && ...
                props_layer.c > 0 && props_layer.rho > 0 && props_layer.alpha_dB_m >= 0 && props_layer.alpha_freq_Hz > 0
                 layer_material_valid = true;
             else
                 warning('Layer material "%s" found but has invalid/missing properties (c, rho, alpha_dB_m, alpha_freq_Hz).', layer_info.layer_material_name);
             end
        else
             warning('Layer material "%s" not found in database.', layer_info.layer_material_name);
        end

        if ~layer_material_valid
             warning('Skipping layer definition due to invalid/missing material properties.');
        else
            z_if_front = layer_info.z_interface_front;
            z_if_back = layer_info.z_interface_back;

            % Find grid indices corresponding to layer interfaces
             [~, z_idx_front] = min(abs(kgrid.z_vec - z_if_front));
             [~, z_idx_back] = min(abs(kgrid.z_vec - z_if_back));
             z1 = min(z_idx_back, z_idx_front);
             z2 = max(z_idx_back, z_idx_front);

            if z1 < z2 % Check if layer has non-zero thickness in grid
                 fprintf('   Defining layer (%s) properties in grid Z indices %d to %d.\n', layer_info.layer_material_name, z1, z2);
                 medium.sound_speed(:,:, z1:z2) = props_layer.c;
                 medium.density(:,:, z1:z2) = props_layer.rho;

                 % Calculate layer's alpha_coeff using the CHOSEN SCALAR medium.alpha_power
                 fprintf('     -> Calculating layer alpha_coeff using chosen power y=%.2f\n', medium.alpha_power);
                 alpha_coeff_layer = db2neper(props_layer.alpha_dB_m, props_layer.alpha_freq_Hz, medium.alpha_power);
                 medium.alpha_coeff(:,:, z1:z2) = alpha_coeff_layer;

                 % --- Spatially varying ALPHA POWER logic was removed ---
            else
                 warning('Layer thickness is too small to be resolved by k-Wave grid (z_idx1=%d, z_idx2=%d). Layer properties not applied.', z1, z2);
            end
        end % end if layer_material_valid
    end % end if ~air_only

    % --- Check for non-finite values in medium struct ---
    fields_to_check = {'sound_speed', 'density', 'alpha_coeff', 'alpha_power'};
    for f_idx = 1:length(fields_to_check)
        fn = fields_to_check{f_idx};
        if isfield(medium, fn) && any(~isfinite(medium.(fn)(:)))
             warning('Non-finite values found in medium.%s after definition. Replacing with defaults/zeros.', fn);
             if strcmp(fn, 'alpha_power'), medium.(fn) = 1; % Default power
             elseif strcmp(fn,'sound_speed'), medium.(fn)(~isfinite(medium.(fn)))=props_front.c; % default speed
             elseif strcmp(fn,'density'), medium.(fn)(~isfinite(medium.(fn)))=props_front.rho; % default density
             else medium.(fn)(~isfinite(medium.(fn)))=0; end % default 0 coeff
        end
    end

end % End define_kwave_medium function



function source = define_kwave_source(kgrid, source_pos, source_signal)
    % Creates the k-Wave source struct for a single point source
    Nx=kgrid.Nx; Ny=kgrid.Ny; Nz=kgrid.Nz; dx=kgrid.dx; dy=kgrid.dy; dz=kgrid.dz;
    source = struct(); source.p_mask = zeros(Nx, Ny, Nz);
    sx = source_pos(1); sy = source_pos(2); sz = source_pos(3);
    [~, idx_x] = min(abs(kgrid.x_vec - sx));
    [~, idx_y] = min(abs(kgrid.y_vec - sy));
    [~, idx_z] = min(abs(kgrid.z_vec - sz));

    % Check if source is within the computational domain (excluding PML)
    % A simple check - is it far enough from boundaries?
    pml_sz = 5; % Need PML size here, assume 5 if not passed - TODO: Pass PML size
    if idx_x > pml_sz && idx_x <= Nx-pml_sz && idx_y > pml_sz && idx_y <= Ny-pml_sz && idx_z > pml_sz && idx_z <= Nz-pml_sz
        source.p_mask(idx_x, idx_y, idx_z) = 1;
        source.p = source_signal;
    else
        source = []; % Indicate source is outside grid or in PML
        warning('Source at [%.3f, %.3f, %.3f] maps to grid index (%d,%d,%d) which may be outside computational domain or in PML.', sx, sy, sz, idx_x, idx_y, idx_z);
    end
end

function H_col_ordered = map_grid_to_points(H_col_unordered_grid, sensor_mask, receiver_points, kgrid)
     % Maps the pressure values from k-Wave sensor indices back to the order of receiver_points
     num_receivers = size(receiver_points, 1);
     H_col_ordered = complex(zeros(num_receivers, 1));
     sensor_indices_lin = find(sensor_mask(:)); % Linear indices where sensors are on the grid

      % Check consistency
      if length(sensor_indices_lin) ~= size(H_col_unordered_grid, 1)
           warning('Mismatch k-Wave output rows (%d) and sensor mask count (%d). Mapping might be incorrect.', size(H_col_unordered_grid, 1), length(sensor_indices_lin));
           % Attempt to proceed if possible, otherwise error
           if size(H_col_unordered_grid, 1) > length(sensor_indices_lin)
               H_col_unordered_grid = H_col_unordered_grid(1:length(sensor_indices_lin)); % Truncate if needed
           else
               error('Cannot reconcile k-Wave output size and sensor mask.');
           end
      end

     [sx, sy, sz] = ind2sub(size(sensor_mask), sensor_indices_lin);
     sensor_pos_grid = [kgrid.x_vec(sx)'; kgrid.y_vec(sy)'; kgrid.z_vec(sz)']'; % Get XYZ of grid sensor points

     for i = 1:num_receivers
         % Find the grid sensor point closest to the i-th receiver point
         dist_sq = sum((sensor_pos_grid - receiver_points(i,:)).^2, 2);
         [min_dist_sq, closest_idx_in_list] = min(dist_sq); % Index within the list of active sensors

         % Check if the mapping is unique and reasonably close (optional)
         if sqrt(min_dist_sq) > max([kgrid.dx, kgrid.dy, kgrid.dz]) * 1.5
             warning('Mapping distance large for receiver %d (%.2f mm). Check grid/sensor definitions.', i, sqrt(min_dist_sq)*1000);
         end

         if closest_idx_in_list <= length(H_col_unordered_grid)
             H_col_ordered(i) = H_col_unordered_grid(closest_idx_in_list);
         else
             warning('Could not map receiver %d to k-Wave sensor data index %d.', i, closest_idx_in_list);
              H_col_ordered(i) = NaN; % Mark as problematic
         end
     end
end

function alpha_Np_m_per_omega_y = db2neper(alpha_db_m, f_ref_hz, y)
    % Converts dB/m at ref freq to Neper/m/(rad/s)^y for k-Wave's alpha_coeff
    % y is the CHOSEN scalar power law exponent for the simulation
    if nargin < 3, y = 1.0; end % Default power law exponent if not given

    % Input validation
    if ~isscalar(alpha_db_m) || ~isfinite(alpha_db_m) || alpha_db_m < 0 || ...
       ~isscalar(f_ref_hz) || ~isfinite(f_ref_hz) || f_ref_hz <= 0 || ...
       ~isscalar(y) || ~isfinite(y)
        warning('db2neper: Invalid input(s). alpha_dB_m=%.2e, f_ref_hz=%.2e, y=%.2f. Returning 0.', alpha_db_m, f_ref_hz, y);
        alpha_Np_m_per_omega_y = 0; return;
    end

    alpha_Np_m_ref = alpha_db_m / 8.685889638; % Convert dB/m to Np/m at ref freq
    omega_ref = 2 * pi * f_ref_hz;

    % Check for potential division by zero or invalid power result
    omega_ref_pow_y = omega_ref^y;
    if omega_ref < 1e-9 || omega_ref_pow_y < 1e-15 || ~isfinite(omega_ref_pow_y)
        if alpha_Np_m_ref == 0 % If no attenuation specified, coeff is 0
            alpha_Np_m_per_omega_y = 0;
        else % If attenuation requested but calculation leads to issue, warn and return 0
            warning('db2neper: Calculation resulted in division by near-zero or non-finite omega_ref^y (%.2e). Attenuation coeff set to 0.', omega_ref_pow_y);
            alpha_Np_m_per_omega_y = 0;
        end
        return;
    end

    % Calculate the coefficient
    alpha_Np_m_per_omega_y = alpha_Np_m_ref / omega_ref_pow_y;

    % Final check for non-finite result
    if ~isfinite(alpha_Np_m_per_omega_y)
        warning('db2neper resulted in non-finite alpha_coeff (%.2e). Check inputs. Setting coeff to 0.', alpha_Np_m_per_omega_y);
        alpha_Np_m_per_omega_y = 0;
    end
end

% --- Modified define_kwave_sensor ---
function [sensor, mapping_info] = define_kwave_sensor(kgrid, receiver_points)
    % Creates the k-Wave sensor struct (only fields k-Wave needs)
    % and separate mapping info.
    % <<< MODIFIED to return a cleaner sensor struct >>>

    Nx=kgrid.Nx; Ny=kgrid.Ny; Nz=kgrid.Nz;
    num_receivers = size(receiver_points, 1);

    % Initialize the sensor struct with ONLY k-Wave fields
    sensor = struct();
    sensor.mask = zeros(Nx, Ny, Nz);
    sensor.record = {'p'}; % Record pressure

    % Initialize separate mapping info (optional, if needed elsewhere)
    mapping_info = struct();
    mapping_info.location_indices_grid = NaN(num_receivers, 1); % Store grid linear index for each receiver
    % mapping_info.point_map_grid = zeros(Nx*Ny*Nz, 1); % Map grid linear index back - Maybe not needed
    mapping_info.num_sensors_mapped = 0; % Count of unique grid points used

    mapped_count = 0;
    % Keep track of occupied grid points to avoid duplicates in the mask
    occupied_lin_indices = [];

    for i = 1:num_receivers
        rx = receiver_points(i,1); ry = receiver_points(i,2); rz = receiver_points(i,3);

        % Find nearest grid point index using interpolation (robust)
        idx_x = interp1(kgrid.x_vec, 1:Nx, rx, 'nearest', 'extrap');
        idx_y = interp1(kgrid.y_vec, 1:Ny, ry, 'nearest', 'extrap');
        idx_z = interp1(kgrid.z_vec, 1:Nz, rz, 'nearest', 'extrap');

        % Check if indices are valid and within grid bounds
        if isnan(idx_x) || idx_x < 1 || idx_x > Nx || ...
           isnan(idx_y) || idx_y < 1 || idx_y > Ny || ...
           isnan(idx_z) || idx_z < 1 || idx_z > Nz
            warning('Receiver point %d [%.3f, %.3f, %.3f] is outside the k-Wave grid. Ignoring.', i, rx, ry, rz);
            mapping_info.location_indices_grid(i) = NaN;
            continue; % Skip to next receiver
        end

        lin_idx = sub2ind([Nx, Ny, Nz], idx_x, idx_y, idx_z);

        % Check if this grid point is already taken for the mask
        if ~ismember(lin_idx, occupied_lin_indices)
            % Grid point is new, mark it in the mask and record it
            sensor.mask(idx_x, idx_y, idx_z) = 1;
            occupied_lin_indices = [occupied_lin_indices; lin_idx]; % Add to list of used points
            mapped_count = mapped_count + 1;
            mapping_info.location_indices_grid(i) = lin_idx; % Store grid index for this receiver
        else
            % Grid point collision
            warning('Receiver point %d maps to the same grid location (%d,%d,%d) as another point. Only one sensor placed at this grid point.', i, idx_x, idx_y, idx_z);
             % Store the grid index, but note it resulted in collision (no new mask point)
            mapping_info.location_indices_grid(i) = lin_idx;
        end
    end

    mapping_info.num_sensors_mapped = mapped_count; % Store final count of unique locations used in mask

    if mapped_count == 0
        warning('define_kwave_sensor: No receiver points were mapped to the grid sensor mask!');
    elseif mapped_count < num_receivers
        num_collisions_or_outside = num_receivers - mapped_count;
        warning('define_kwave_sensor: Placed %d unique sensors in mask for %d receiver points. %d points ignored (outside grid or collision).', mapped_count, num_receivers, num_collisions_or_outside);
    end

    fprintf('   Sensor mask defined with %d unique active points.\n', mapped_count);

end % End define_kwave_sensor

function residual = calculate_nah_residual_for_ga(x, fixed_data)
% Objective function for GA to minimize NAH residual by varying material properties.
% MODIFIED to utilize GPU for k-Wave H matrix and Tikhonov/TSVD solvers.
% Input:
%   x: Vector of current parameter guesses [c, rho, alpha_dB_m, thickness]
%   fixed_data: Struct containing fixed parameters and data from main script
% Output:
%   residual: Scalar value of the relative residual norm

    % --- Default residual for errors ---
    residual = 1e10; % High penalty

    try
        % --- Unpack fixed data ---
        p_meas_vec_cpu     = fixed_data.p_meas_vec; % Keep original CPU version
        current_omega      = fixed_data.current_omega;
        material_to_optimize = fixed_data.material_to_optimize;
        params             = fixed_data.params_template; % Use template
        layer_info         = fixed_data.layer_info_template; % Use template
        mic_coords_raw     = fixed_data.mic_coords_raw;
        esm_points_initial = fixed_data.esm_points_initial;
        solver_method      = fixed_data.solver_method;
        sbl_params         = fixed_data.sbl_params; % Needed if using SBL

        % Determine if GPU should be used based on main script setting
        use_gpu_for_solver = params.kwave_gpu_available_and_selected; % Use the flag set in main script

        % --- Update params & layer_info with current guess 'x' ---
        current_c       = x(1);
        current_rho     = x(2);
        current_alpha   = x(3);
        current_thick   = x(4);

        % Modify a *copy* of the database for this evaluation
        params.material_database.(material_to_optimize).c = current_c;
        params.material_database.(material_to_optimize).rho = current_rho;
        params.material_database.(material_to_optimize).alpha_dB_m = current_alpha;
        params.layer_thickness = current_thick; % Update thickness in params copy

        % Update layer_info struct (crucial!) using the modified params copy
        layer_info.db = params.material_database; % Point to the modified db
        layer_info.thickness = params.layer_thickness;
        mean_mic_z = mean(mic_coords_raw(:,3));
        layer_front_z = mean_mic_z - params.dist_mic_to_front_surface;
        layer_info.z_interface_front = layer_front_z;
        layer_info.z_interface_back = layer_front_z - layer_info.thickness;

        % --- Perform minimal NAH steps to get residual ---

        % 1. Calculate H_esm (FORCE RECOMPUTE because thickness changes geometry)
        H_esm_curr_cpu = []; N_esm_valid = 0; deleteIndexesVirt_esm = []; % Start with CPU var names
        current_esm_points = esm_points_initial; % Start with initial points
        num_esm_initial = size(current_esm_points, 1);

        if params.use_kwave_propagator
            kwave_params = struct();
            kwave_params.ppw = params.kwave_ppw;
            kwave_params.CFL = params.kwave_CFL;
            kwave_params.kwave_gpu_available_and_selected = params.kwave_gpu_available_and_selected;
            kwave_params.t_end_factor = params.kwave_t_end_factor;
            kwave_params.pml_size = params.kwave_pml_size;
            kwave_params.cache_dir = params.kwave_cache_dir;
            kwave_params.force_recompute = true; % <<< MUST BE TRUE FOR GA WITH THICKNESS OPT >>>
            kwave_params.caller_id = 'H_esm_GA'; % Different ID for GA runs

            % compute_H_kwave now uses GPU internally if available & selected
            [H_esm_data, ~] = compute_H_kwave(mic_coords_raw, current_esm_points, current_omega, layer_info, kwave_params);

            if isempty(H_esm_data) || ~isfield(H_esm_data,'H') || isempty(H_esm_data.H)
                 fprintf('GA: k-Wave H_esm failed for params: c=%.1f, rho=%.1f, alpha=%.1f, thick=%.4f\n',x(1),x(2),x(3),x(4));
                 return; % Return high penalty residual
            end
            % Result H from compute_H_kwave is currently double on CPU
            H_esm_curr_cpu = H_esm_data.H;
            deleteIndexesVirt_esm = H_esm_data.deleteIndexesSrc;
            N_esm_valid = H_esm_data.N_src_valid;
        else % Analytical
             % TODO: Consider modifying Green_matrix_multilayer_revised to use GPU if needed
             [G_esm_cell, deleteIndexesVirt_esm, N_esm_valid] = Green_matrix_multilayer_revised(mic_coords_raw, current_esm_points, current_omega, layer_info);
             if isempty(G_esm_cell) || N_esm_valid == 0
                  fprintf('GA: Analytical H_esm failed for params: c=%.1f, rho=%.1f, alpha=%.1f, thick=%.4f\n',x(1),x(2),x(3),x(4));
                  return; % Return high penalty residual
             end
             H_esm_curr_cpu = G_esm_cell{1};
        end

        % Update ESM points list based on propagator result
        if ~isempty(deleteIndexesVirt_esm)
            current_esm_points(deleteIndexesVirt_esm,:) = []; % Note: current_esm_points not used after this
             if N_esm_valid ~= size(current_esm_points, 1)
                 fprintf('GA: N_esm_valid mismatch after deleting points.\n'); return;
             end
        end
        if N_esm_valid ~= size(H_esm_curr_cpu, 2)
            fprintf('GA: N_esm_valid mismatch H_esm columns.\n'); return;
        end
        if N_esm_valid == 0
            fprintf('GA: No valid ESM sources remaining.\n'); return;
        end

        % Basic check on H_esm (CPU version)
        if any(isnan(H_esm_curr_cpu(:))) || any(isinf(H_esm_curr_cpu(:)))
             fprintf('GA: H_esm contains NaN/Inf.\n'); return;
        end

        % --- Cast inputs to GPU SINGLE precision if using GPU for solver ---
        if use_gpu_for_solver
            try
                H_esm_curr = gpuArray(single(H_esm_curr_cpu));
                p_meas_vec = gpuArray(single(p_meas_vec_cpu));
                norm_p_meas = max(norm(p_meas_vec), eps('single')); % Norm on GPU
                % Clear CPU copies if memory is tight (optional)
                % clear H_esm_curr_cpu p_meas_vec_cpu;
            catch ME_gpu_cast
                 fprintf('GA: Error casting to gpuArray: %s. Falling back to CPU solver.\n', ME_gpu_cast.message);
                 use_gpu_for_solver = false; % Fallback
                 H_esm_curr = H_esm_curr_cpu; % Use CPU double
                 p_meas_vec = p_meas_vec_cpu;
                 norm_p_meas = max(norm(p_meas_vec), eps('double'));
            end
        else
            % Use CPU double versions
            H_esm_curr = H_esm_curr_cpu;
            p_meas_vec = p_meas_vec_cpu;
            norm_p_meas = max(norm(p_meas_vec), eps('double'));
        end
        % --- End Cast ---

        % 2. Solve for q_esm
        q_esm_final = []; % Initialize on CPU, cast later if needed by residual calc
        temp_recon_info = struct(); % Temporary info struct for solver

        switch lower(solver_method)
            case 'tikhonov'
                % Operations run on GPU if H_esm_curr, p_meas_vec are gpuArrays
                H_esm_t = H_esm_curr';
                Hesm_t_Hesm = H_esm_t * H_esm_curr;
                norm_HtH = norm(Hesm_t_Hesm, 'fro');
                lambda_rel_val = params.esm_tikhonov_lambda_rel;
                % Ensure lambda calculation uses same type as matrix
                lambda_abs = lambda_rel_val * norm_HtH;
                lambda_abs = max(lambda_abs, eps(class(H_esm_curr)) * norm_HtH); % Use eps of correct type

                % Use 'like' syntax for identity matrix type matching
                A_tik = Hesm_t_Hesm + lambda_abs * eye(size(Hesm_t_Hesm), 'like', Hesm_t_Hesm);
                rhs = H_esm_t * p_meas_vec;
                q_esm_final_gpu_or_cpu = A_tik \ rhs; % Solve on GPU/CPU
                q_esm_final = gather(q_esm_final_gpu_or_cpu); % Bring result to CPU double
                clear q_esm_final_gpu_or_cpu A_tik rhs H_esm_t Hesm_t_Hesm; % Clear intermediates

             case 'tsvd'
                 % Modify tsvd_reconstruction or use gpu_tsvd_reconstruction if available
                 % Assuming tsvd_reconstruction works with gpuArrays or we have a gpu version
                 if use_gpu_for_solver && exist('gpu_tsvd_reconstruction','file') % Check for specific GPU version
                      [q_esm_final_gpu, ~] = gpu_tsvd_reconstruction(H_esm_curr, p_meas_vec, params.esm_tsvd_k_abs, params.esm_tsvd_k_ratio, params.esm_tsvd_alpha);
                      q_esm_final = gather(q_esm_final_gpu); % Bring result to CPU double
                      clear q_esm_final_gpu;
                 elseif use_gpu_for_solver && ~exist('gpu_tsvd_reconstruction','file')
                      % Attempt standard TSVD, hoping internal svd/mtimes uses GPU
                      warning('gpu_tsvd_reconstruction not found. Using standard tsvd_reconstruction on GPU data (may be slow).')
                      [q_esm_final_gpu, ~] = tsvd_reconstruction(H_esm_curr, p_meas_vec, params.esm_tsvd_k_abs, params.esm_tsvd_k_ratio, params.esm_tsvd_alpha);
                      q_esm_final = gather(q_esm_final_gpu);
                      clear q_esm_final_gpu;
                 else % Use CPU
                     [q_esm_final, ~] = tsvd_reconstruction(H_esm_curr, p_meas_vec, params.esm_tsvd_k_abs, params.esm_tsvd_k_ratio, params.esm_tsvd_alpha);
                 end

             case 'sbl'
                 % SBL runs on CPU and needs DOUBLE precision inputs
                 if use_gpu_for_solver
                      fprintf('   Gathering H/p from GPU and casting to double for SBL...\n'); % DEBUG
                      H_esm_curr_sbl = double(gather(H_esm_curr)); % Gather AND cast to double
                      p_meas_vec_sbl = double(gather(p_meas_vec)); % Gather AND cast to double
                 else
                      % Ensure inputs are double if coming from CPU path (should be already)
                      H_esm_curr_sbl = double(H_esm_curr);
                      p_meas_vec_sbl = double(p_meas_vec);
                 end
                 sbl_params_ga = sbl_params; % Copy params
                 sbl_params_ga.esm_sbl_plot = false; % Disable plotting in GA
                 sbl_params_ga.esm_sbl_track = false;% Disable tracking in GA

                 fprintf('   Calling SBL with CPU double data (size H: %s)...\n', mat2str(size(H_esm_curr_sbl))); % DEBUG
                 [q_esm_final, ~, ~, ~, temp_recon_info] = sparse_bayesian_learning_original(H_esm_curr_sbl, p_meas_vec_sbl, params.esm_sbl_max_iter, sbl_params_ga);

                 clear H_esm_curr_sbl p_meas_vec_sbl; % Clear CPU copies used only by SBL
                 % Check if SBL failed explicitly
                 if isfield(temp_recon_info,'message') && contains(temp_recon_info.message,'fail','IgnoreCase',true)
                      fprintf('GA: SBL solver failed.\n'); return;
                 end

            case 'l1_tv'
                 % L1-TV placeholder runs on CPU
                  if use_gpu_for_solver
                      H_esm_curr_l1 = gather(H_esm_curr); % Bring H back to CPU
                      p_meas_vec_l1 = gather(p_meas_vec); % Bring p back to CPU
                 else
                      H_esm_curr_l1 = H_esm_curr; % Already on CPU
                      p_meas_vec_l1 = p_meas_vec;
                 end
                 [q_esm_final, ~] = l1_tv_reconstruction(H_esm_curr_l1, p_meas_vec_l1, params.esm_l1_tv_lambda_l1, params.esm_l1_tv_lambda_tv, params.esm_l1_tv_max_iter, params.N, params.esm_l1_tv_tolerance);
                 clear H_esm_curr_l1 p_meas_vec_l1;

            otherwise
                error('GA Objective: Unknown solver method');
        end

        % Check solver output (now q_esm_final is on CPU, double)
        if isempty(q_esm_final) || any(isnan(q_esm_final(:))) || any(isinf(q_esm_final(:))) || length(q_esm_final) ~= N_esm_valid
             fprintf('GA: Solver failed or produced invalid q_esm for params: c=%.1f, rho=%.1f, alpha=%.1f, thick=%.4f\n',x(1),x(2),x(3),x(4));
             return; % Return high penalty residual
        end

        % 3. Calculate Residual (Perform on GPU if possible)
        if use_gpu_for_solver
            % H_esm_curr and p_meas_vec should still be on GPU
            q_esm_final_gpu = gpuArray(single(q_esm_final)); % Cast q to GPU single
            residual_vec_gpu = H_esm_curr * q_esm_final_gpu - p_meas_vec;
            residual_norm_gpu = norm(residual_vec_gpu);
            residual = gather(residual_norm_gpu / norm_p_meas); % Gather scalar residual
            clear q_esm_final_gpu residual_vec_gpu residual_norm_gpu; % Clear GPU intermediates
        else
            % All calculations on CPU
            residual_vec = H_esm_curr * q_esm_final - p_meas_vec;
            residual = norm(residual_vec) / norm_p_meas; % Already scalar
        end

        % --- Add constraint penalty if residual is NaN/Inf ---
        if isnan(residual) || isinf(residual) || residual < 0
            fprintf('GA: Calculated residual is NaN/Inf/Negative (%.4e) for params: c=%.1f, rho=%.1f, alpha=%.1f, thick=%.4f\n', residual, x(1),x(2),x(3),x(4));
            residual = 1e10; % High penalty
        end

        % Optional: Print progress (can be verbose)
        % fprintf('  GA Eval: c=%.1f,rho=%.1f,a=%.1f,th=%.4f -> Res=%.4f\n', x(1),x(2),x(3),x(4), residual);

    catch ME_objective
        fprintf('*** ERROR in GA Objective Function: %s ***\n', ME_objective.message);
        if exist('x','var') % Check if x exists before trying to access it
             fprintf('    Params: c=%.1f, rho=%.1f, alpha=%.1f, thick=%.4f\n',x(1),x(2),x(3),x(4));
        else
             fprintf('    Params: Error occurred before parameters x could be read.\n');
        end
        fprintf('    Occurred in %s at line %d\n', ME_objective.stack(1).name, ME_objective.stack(1).line);
        residual = 1e10; % Return high penalty
    end

    % Ensure residual is double for GA compatibility
    residual = double(residual);

end % End of objective function

% --- TMM Multi-Layer Green's Function --- %%% <<< NEW FUNCTION >>>
function [G, deleteIdx, N_valid] = Green_matrix_multilayer_TMM(hologramPoints, virtualPoints, omega, layer_info)
% Full 3-layer Transfer-Matrix Method for planar interface propagation.
% Assumes source is in medium 0 ('air_back'), layer is medium 1, receiver in medium 2 ('air_front').
% Handles oblique incidence and multiple reflections within the layer.

    % --- Input Validation & Setup ---
    if size(hologramPoints,2)~=3 || size(virtualPoints,2)~=3, error('TMM G: Input points must be M x 3.'); end
    deleteIdx = find(any(isnan(virtualPoints),2)); virtualPoints(deleteIdx,:) = []; % Remove NaN sources
    nan_rows_holo = find(any(isnan(hologramPoints), 2)); if ~isempty(nan_rows_holo), warning('TMM G: Removing %d hologram points with NaN coords!', length(nan_rows_holo)); hologramPoints(nan_rows_holo,:) = []; end
    M = size(hologramPoints,1); N = size(virtualPoints,1); N_valid = N;
    if M==0 || N==0, warning('TMM G: No valid points after NaN removal.'); G={}; return; end
    G_mat = zeros(M, N, 'like', 1i); % Initialize Green's matrix

    % --- Get Material Properties and Interface Locations ---
    db = layer_info.db;
    prop0 = db.(layer_info.material_air_back_name); % Medium 0 (source side, e.g., air)
    prop1 = db.(layer_info.layer_material_name); % Medium 1 (layer)
    prop2 = db.(layer_info.material_air_front_name); % Medium 2 (receiver side, e.g., air)
    z_if_back = layer_info.z_interface_back;   % Interface 0->1 (closer to source)
    z_if_front = layer_info.z_interface_front; % Interface 1->2 (closer to receiver)
    L = layer_info.thickness; % Layer thickness

    % --- Precompute Complex Wavenumbers & Impedances ---
    % Note: Using convention exp(i*omega*t - i*k*r)
    k0 = get_complex_wavenumber(prop0, omega); k1 = get_complex_wavenumber(prop1, omega); k2 = get_complex_wavenumber(prop2, omega);
    Z0 = get_complex_impedance(prop0, omega, k0); Z1 = get_complex_impedance(prop1, omega, k1); Z2 = get_complex_impedance(prop2, omega, k2);
    if abs(Z0)<eps || abs(Z1)<eps || abs(Z2)<eps, warning('TMM G: Zero impedance encountered.'); end

    % --- TMM Calculation Function (for a given parallel wavenumber k_rho) ---
    function T12 = tmm_transmission_k_rho(k_rho)
        % Calculate z-components of wavenumbers using dispersion relation
        kz0 = sqrt(k0^2 - k_rho^2); if imag(kz0) > 0, kz0 = -kz0; end % Ensure decaying/outward prop
        kz1 = sqrt(k1^2 - k_rho^2); if imag(kz1) > 0, kz1 = -kz1; end
        kz2 = sqrt(k2^2 - k_rho^2); if imag(kz2) > 0, kz2 = -kz2; end

        % Check for NaN/Inf kz (can happen if k_rho is too large)
        if ~isfinite(kz0) || ~isfinite(kz1) || ~isfinite(kz2), T12 = 0; return; end

        % Reflection/Transmission at interface 0->1 (Z0,Z1,kz0,kz1)
        R01 = (Z1*kz0 - Z0*kz1) / (Z1*kz0 + Z0*kz1);
        T01 = (2 * Z1 * kz0) / (Z1*kz0 + Z0*kz1); % Note: Transmission into layer impedance Z1

        % Reflection/Transmission at interface 1->2 (Z1,Z2,kz1,kz2)
        R12 = (Z2*kz1 - Z1*kz2) / (Z2*kz1 + Z1*kz2);
        T12_interface = (2 * Z2 * kz1) / (Z2*kz1 + Z1*kz2); % Trans into medium 2 impedance Z2

        % Phase propagation across layer
        phase = exp(1i * kz1 * L); % Using +i due to k definition

        % Total transmission through the layer (handles multiple reflections)
        % This is the transmission coefficient for pressure/potential from medium 0 to 2
        T12 = (T01 * T12_interface * phase) / (1 + R01 * R12 * phase^2);

        if ~isfinite(T12), T12 = 0; end % Handle potential division by zero or NaN
    end

    % --- Loop through source/receiver pairs ---
    tiny_dist = 1e-9;
    for jj = 1:N % Source index
        r_v = virtualPoints(jj, :); % Source position [xv, yv, zv]
        if r_v(3) >= z_if_back % Source must be in medium 0 (z < z_if_back)
             warning('TMM G: Source %d at z=%.4f is not in source medium (z < %.4f). Skipping.', jj, r_v(3), z_if_back);
             G_mat(:, jj) = 0; % Or NaN? Let's use 0.
             continue;
        end

        for ii = 1:M % Receiver index
            r_h = hologramPoints(ii, :); % Receiver position [xh, yh, zh]
            if r_h(3) <= z_if_front % Receiver must be in medium 2 (z > z_if_front)
                 warning('TMM G: Receiver %d at z=%.4f is not in receiver medium (z > %.4f). Skipping.', ii, r_h(3), z_if_front);
                 G_mat(ii, jj) = 0;
                 continue;
            end

            % Vector from source to receiver
            R_vec = r_h - r_v;
            dist_total = norm(R_vec); if dist_total < tiny_dist, dist_total = tiny_dist; end
            dist_rho_sq = R_vec(1)^2 + R_vec(2)^2;

            % --- Calculate equivalent k_rho (parallel wavenumber) ---
            % This requires an iterative solution or approximation if source/receiver not aligned vertically
            % Approximation: Use the angle defined by the direct path
            if dist_total > tiny_dist
                sin_theta_approx = sqrt(dist_rho_sq) / dist_total;
            else
                sin_theta_approx = 0;
            end
            k_rho_approx = k0 * sin_theta_approx; % Use wavenumber in source medium

            % Get transmission coefficient for this approximate parallel wavenumber
            T_eff = tmm_transmission_k_rho(k_rho_approx);

            % Calculate Green's function - using spherical wave from source + transmission factor
            % The phase should ideally account for propagation in each medium, but TMM accounts for phase shifts.
            % Use effective wavenumber of the final medium (k2) for the phase factor of the transmitted wave?
            % Or use k0 and let T_eff handle the rest? Let's try using k0.
            G_mat(ii, jj) = T_eff * exp(1i * k0 * dist_total) / (4 * pi * dist_total);

            if ~isfinite(G_mat(ii, jj)), G_mat(ii, jj) = 0; end % Final check
        end
    end

    G = {G_mat}; % Return as cell
end

% --- L1-TV Solver (Split-Bregman) --- %%% <<< NEW FUNCTION >>>
function [z, info] = l1_tv_reconstruction(G, p, lambda_l1, lambda_tv, maxIter, N_side, tol)
% Solves:  min_z  0.5*||Gz - p||_2^2 + lambda1*||z||_1 + lambda_tv*TV(z)
% via Split-Bregman. Assumes CPU double inputs.
% N_side is used to reshape z for TV term if lambda_tv > 0.

    [M,N] = size(G);
    info = struct('iterations',0,'relative_residual',NaN,'message','L1TV Init','final_grad_norm_rel', NaN);
    z = zeros(N,1); % Initialize z

    % Check for Image Proc Toolbox only if TV is requested
    has_img_tbx = false; use_tv = false;
    if lambda_tv > 0
        if N_side^2 ~= N, warning('L1TV: N=%d not a perfect square. Cannot apply TV term.', N);
        elseif ~license('test','image_toolbox') || ~exist('imdiffusefilt','file') , warning('L1TV: Image Proc Tbx or imdiffusefilt unavailable. Cannot apply TV term.');
        else has_img_tbx = true; use_tv = true; end
    end

    % Precompute
    try GTG = G'*G; catch ME_mem, error('L1TV: Failed G''*G (memory?): %s', ME_mem.message); end
    GTp = G'*p;

    % Initialize Split-Bregman variables
    d = z; bx = zeros(N,1); % For L1 term: z=d
    e = []; by = []; D = []; % For TV term: Dz=e
    mu1 = 1.0; mu2 = 1.0; % Bregman parameters

    if use_tv
        % Difference operator for TV (simple forward difference)
        Dx = spdiags([-ones(N,1) ones(N,1)], [0 N_side], N, N); % Diff along columns
        Dy = spdiags([-ones(N,1) ones(N,1)], [0 1], N, N); % Diff along rows
        % Correct boundary conditions for reshape (wrap or zero?) - simple zero for now
        Dx = Dx(1:N-N_side,:); Dy = Dy(1:N-1,:); Dy(N_side:N_side:end,:) = 0;
        D = [Dx; Dy]; % Combined difference operator [2N-N_side-1 x N approx]
        e = zeros(size(D,1),1); by = zeros(size(D,1),1); % Initialize TV aux vars
        DtD = D'*D; % Precompute D'*D
        mu2 = 1.0; % Set TV penalty weight
    else
        DtD = sparse(N,N); % Zero matrix if no TV
        mu2 = 0; % No TV penalty
    end

    fprintf('  L1TV Start: Lam1=%.2e, LamTV=%.2e (UseTV=%d), MaxIter=%d, Tol=%.1e\n', lambda_l1, lambda_tv, use_tv, maxIter, tol);

    k = 0; % Initialize iteration count
    for k = 1:maxIter
        z_old = z;

        % zsubproblem (solve linear system)
        A = GTG + (mu1 + mu2)*speye(N) + mu2*(DtD - speye(N)); % Combined system matrix (uses DtD only if use_tv)
        b = GTp + mu1*(d - bx);
        if use_tv, b = b + mu2*(D'*(e - by)); end % Add TV term to RHS if active

        try z = A \ b; catch ME_linsolve, error('L1TV Iter %d: Linear solve failed: %s', k, ME_linsolve.message); end

        % dsubproblem (L1 soft threshold)
        u = z + bx;
        d = sign(u).*max(abs(u) - lambda_l1/mu1, 0);

        % esubproblem (TV soft threshold, if active)
        if use_tv
            v = D*z + by;
            e = sign(v).*max(abs(v) - lambda_tv/mu2, 0); % Isotropic TV prox approx? Check literature.
        end

        % Bregman updates
        bx = bx + (z - d);
        if use_tv, by = by + (D*z - e); end

        % Check convergence (relative change in z)
        if norm(z - z_old)/max(norm(z_old),eps) < tol
            info.message = 'Converged'; break;
        end
    end

    info.iterations = k;
    info.relative_residual = norm(G*z - p)/max(norm(p),eps);
    % Calculate final gradient norm for diagnostics (optional)
    grad_l1 = mu1*(z-d); % Subgradient part for L1
    grad_tv = 0; if use_tv, grad_tv = mu2*D'*(D*z - e); end % Subgradient part for TV
    grad_dataterm = G'*(G*z - p);
    info.final_grad_norm_rel = norm(grad_dataterm + grad_l1 + grad_tv) / max(norm(GTp),eps);

    fprintf('  L1TV End: Iter=%d, RelRes=%.4f, Stop=%s, FinalGradNorm=%.2e\n', info.iterations, info.relative_residual, info.message, info.final_grad_norm_rel);

end

% --- Multi-Frequency Fusion Wrapper --- %%% <<< NEW FUNCTION >>>
function [recon_map_fused, individual_maps] = multi_freq_ESM(processed_freqs_info, fusion_method, N_grid)
% Fuses multiple single-frequency ESM reconstructions.
% Inputs:
%   processed_freqs_info: Cell array of structs from main loop (contains q_esm, frequency, etc.)
%   fusion_method: 'median', 'mean', or 'max'
%   N_grid: Size of one side of the square reconstruction grid (e.g., params.N)
% Outputs:
%   recon_map_fused: The final fused (normalized) magnitude map.
%   individual_maps: 3D array of the individual normalized maps before fusion.

    num_freqs = length(processed_freqs_info);
    individual_maps = nan(N_grid, N_grid, num_freqs); % Use NaN for failed ones
    fprintf(' Fusing %d frequency maps using "%s" method...\n', num_freqs, fusion_method);

    for i = 1:num_freqs
        info_i = processed_freqs_info{i};
        % Check if this frequency failed (indicated by empty q_esm)
        if isfield(info_i, 'q_esm') && ~isempty(info_i.q_esm) && isfield(info_i, 'p_recon_vec') && ~isempty(info_i.p_recon_vec)
            p_recon_vec_i = info_i.p_recon_vec;
            map_i = abs(reshape(p_recon_vec_i, N_grid, N_grid));
            max_val = max(map_i(:));
            if max_val > eps
                individual_maps(:,:,i) = map_i / max_val; % Normalize
            else
                individual_maps(:,:,i) = zeros(N_grid, N_grid); % Handle zero map
            end
        else
             fprintf('   Skipping frequency %.2f Hz (failed or missing data).\n', info_i.frequency);
             % Keep it as NaN in individual_maps
        end
    end

    % Perform fusion, ignoring NaNs
    switch lower(fusion_method)
        case 'median'
            recon_map_fused = median(individual_maps, 3, 'omitnan');
        case 'mean'
            recon_map_fused = mean(individual_maps, 3, 'omitnan');
        case 'max'
             recon_map_fused = max(individual_maps, [], 3, 'omitnan');
        otherwise % Default to median
             warning('Unknown fusion method "%s". Using median.', fusion_method);
             recon_map_fused = median(individual_maps, 3, 'omitnan');
    end

    % Handle case where all frequencies might have failed for a pixel
    recon_map_fused(isnan(recon_map_fused)) = 0;
    fprintf(' Fusion complete.\n');
end

function s = rmfield_safe(s, fields)
    if ischar(fields)
        fields = {fields};
    end
    for i = 1:numel(fields)
        if isfield(s, fields{i})
            s = rmfield(s, fields{i});
        end
    end
end

function [Z,alpha,info] = sparse_bayesian_learning_group_mmv(Hcell,Pcell,maxIter,params)
%GROUP_MMV_SBL  Robust multifrequency sparse Bayesian learning.
%    ASCIIonly variable names (no Unicode).
%    Columnpruning and SPDaware Cholesky.
%    Damped alpha update to avoid divergence.
%    Compatible with every MATLAB/Octave release.
% ------------------------------------------------------------------
% INPUTS
%   Hcell   {F}  cell array, each MN propagator matrix (same N)
%   Pcell   {F}  cell array, each M1 pressure vector
%   maxIter      maximum EM iterations (default 5000)
%   params       struct with optional fields
%                  .sbl_plot       logical, show convergence plots
%                  .sbl_stop_tol   [dA dZ dR] stopping tolerances
%                  .sbl_damp_tau   damping factor (0<tau<=1, default 0.3)
%                  .sbl_alpha_clip [amin amax] clip range for alpha/beta
% OUTPUTS
%   Z        NF  recovered equivalentsource spectra
%   alpha    N1 final hyperparameters
%   info          struct with diagnostics
% ------------------------------------------------------------------
% Chris, April2025

%% ------------- defaults & dimensions -----------------------------
F        = numel(Hcell);
[M,N]    = size(Hcell{1});
if nargin<3 || isempty(maxIter);  maxIter = 5000; end

pflag    = isfield(params,'sbl_plot')       && params.sbl_plot;
if isfield(params,'sbl_damp_tau');  tau   = params.sbl_damp_tau; else, tau   = 0.3; end
if isfield(params,'sbl_alpha_clip'); aclip = params.sbl_alpha_clip; else, aclip = [1e-12 1e12]; end
if isfield(params,'sbl_stop_tol');  STOP  = params.sbl_stop_tol;  else, STOP  = [1e-3 1e-4 1e-4]; end %[dA dZ dR]
ETA      = eps;

%% ---------------------- column pruning ---------------------------
% Build logical mask: keep column if ANY frequency has nonzero entries
colMaskCell = cellfun(@(H) any(abs(H) > ETA,1), Hcell, 'UniformOutput', false);
colkeep     = any(cat(1,colMaskCell{:}),1);   % 1N logical
if ~all(colkeep)
    fprintf('MMVSBL: pruned %d empty source columns.\n', nnz(~colkeep));
    for f = 1:F, Hcell{f} = Hcell{f}(:,colkeep); end
    N       = nnz(colkeep);
end

%% ------------------- initialise variables ------------------------
Z       = zeros(N,F);
alpha   = ones(N,1);
beta    = ones(1,F);

%% ------------- helper: SPDsafe Cholesky with jitter -------------
    function L = chol_spd(A)
        A = (A+A')*0.5;                       % force symmetry
        jitter = 0; p = 1;
        while p>0
            [L,p] = chol(A,'lower');
            if p>0
                jitter = max(jitter, 1e-6*mean(diag(A)) );
                A      = A + jitter*speye(size(A));
            end
        end
    end

%% ----------------- precompute fixed products --------------------
GtG = cell(1,F); GtP = cell(1,F);
for f = 1:F
    GtG{f} = Hcell{f}' * Hcell{f};
    GtP{f} = Hcell{f}' * Pcell{f};
end

%% ---------------- convergence plot setup -------------------------
if pflag
    figure('Name','MMVSBL convergence');
    subplot(3,1,1); hDa = line(NaN,NaN); title('\Delta{\alpha}'); set(gca,'YScale','log'); grid on;
    subplot(3,1,2); hDz = line(NaN,NaN); title('\Delta{Z}');        set(gca,'YScale','log'); grid on;
    subplot(3,1,3); hRe = line(NaN,NaN); title('rel residual');     set(gca,'YScale','log'); grid on;
end

%% -------------------------- EM loop ------------------------------
Zold = Z;  resOld = Inf;
for it = 1:maxIter
    %% ---- Estep --------------------------------------------------
    gamma = zeros(N,1);
    for f = 1:F
        A     = spdiags(alpha,0,N,N);
        Sigma = (beta(f)*GtG{f} + A) \ eye(N); % SPD guaranteed
        Z(:,f)= beta(f) * Sigma * GtP{f};
        gamma = gamma + (1 - alpha .* diag(Sigma));
        % update beta
        resid    = Pcell{f} - Hcell{f}*Z(:,f);
        beta(f)  = max(aclip(1), min(aclip(2), (M - sum(gamma))/ (resid'*resid + ETA) ));
    end
    gamma = gamma / F;

    %% ---- Mstep --------------------------------------------------
    a_raw = gamma ./ (mean(abs(Z).^2,2) + ETA);
    alpha = max(aclip(1), min(aclip(2), (1-tau).*alpha + tau.*a_raw) );

    %% ---- convergence metrics ------------------------------------
    dA = norm(log10(alpha+ETA) - log10(a_raw+ETA)) / N;
    dZ = norm(Z(:) - Zold(:)) / (norm(Zold(:))+ETA);
    res = zeros(1,F);
    for f = 1:F, res(f) = norm(Pcell{f} - Hcell{f}*Z(:,f)); end
    dR = abs(mean(res) - resOld) / (resOld + ETA);

    if pflag && mod(it,25)==0
        set(hDa,'XData',[get(hDa,'XData') it],'YData',[get(hDa,'YData') dA]);
        set(hDz,'XData',[get(hDz,'XData') it],'YData',[get(hDz,'YData') dZ]);
        set(hRe,'XData',[get(hRe,'XData') it],'YData',[get(hRe,'YData') mean(res)]);
        drawnow;
    end

    if dA<STOP(1) && dZ<STOP(2) && dR<STOP(3)
        break; % converged
    end

    Zold  = Z;  resOld = mean(res);
end

%% ---------------------- info struct ------------------------------
info.iters   = it;
info.delta_a = dA;   info.delta_z = dZ;   info.delta_res = dR;
info.beta    = beta; info.alpha    = alpha;
info.message = tern(it<maxIter,'Converged','MaxIter');

end %=========================== END FUNC ============================

function out = tern(c,a,b); if c, out=a; else, out=b; end; end

%%% >>> MODIFICATION START: Insert the new MR-NAH Solver Function
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  >>> HELPER FUNCTIONS <<<                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ... (Keep existing helper functions) ...

%%% >>> MODIFICATION START: Update/Insert MR-NAH Solver Function
function [Q_final, info] = manifold_regularization_solver(H, P_meas, esm_points, params)
    % Solves the NAH problem using Adaptive Manifold Regularization (MR-NAH).
    % Optimized with Sparse Initialization (ISTA) using Power Iteration.

    fprintf(' -> Entering manifold_regularization_solver (Lambda=%.2e, SigmaX=%.4f)...\n', params.mr_lambda, params.mr_sigma_x);
    
    [~, N] = size(H);
    norm_P = norm(P_meas);
    if norm_P < eps
        Q_final = zeros(N, 1);
        info = struct('message', 'Zero input P_meas', 'iterations', 0, 'relative_residual', 0);
        return;
    end

    % Parameters
    lambda = params.mr_lambda;
    sigma_x_sq = params.mr_sigma_x^2;
    max_iter = params.mr_max_iter;
    tol = params.mr_tol;
    
    % Ensure inputs are double precision
    H = double(H);
    P_meas = double(P_meas);
    esm_points = double(esm_points);
    
    % Precompute spatial distance matrix (Use only X,Y coordinates for the manifold if planar)
    try
        if size(esm_points, 2) >= 2
             coords_for_dist = esm_points(:,1:2);
        else
             coords_for_dist = esm_points;
        end
        dist_sq_matrix = pdist2(coords_for_dist, coords_for_dist).^2;
    catch ME_pdist
        error('MR-NAH: Failed to calculate distance matrix (pdist2). Ensure Statistics Toolbox is installed. Error: %s', ME_pdist.message);
    end
    
    HtH = H' * H;
    HtP = H' * P_meas;
    
    %%% >>> MODIFICATION START: Sparse Initialization (ISTA with Power Iteration)
    % Initialization (Replaced Tikhonov with ISTA)
    fprintf('    Initializing MR-NAH with Sparse Estimate (ISTA)...\n');
    lambda_l1_init = 1e-6; % Heuristic L1 parameter (tune if necessary)
    max_iter_ista_init = 50; 

    x = randn(N,1);
    for k = 1:10
        x = HtH * x;
        x = x / norm(x);
    end
    L = x'*(HtH*x);               
    if ~isfinite(L) || L <= 0
        L = normest(HtH);            % fallback
    end
    alpha_ista = 1/(L + eps);

%{
   %{ % Estimate Lipschitz constant (L) using Power Iteration (fast approximation)
    x = randn(N, 1); L_approx = 1;
    for k = 1:10 % 10 iterations for approximation
        x = HtH * x;
        L_approx = norm(x);
        if L_approx < eps, break; end
        x = x / L_approx;
    end
    L = L_approx;
    if L < eps, L = norm(HtH, 'fro'); end % Fallback
    
    alpha_ista = 1/(L + eps); 
%}

    Q = zeros(N, 1); % Start ISTA from zero
    for iter_ista = 1:max_iter_ista_init
        % Gradient step: HtH*Q - HtP
        grad = HtH * Q - HtP;
        Q_temp = Q - alpha_ista * grad;
        % Complex Soft thresholding
        threshold = lambda_l1_init * alpha_ista;
        Q = sign(Q_temp) .* max(abs(Q_temp) - threshold, 0);
    end
    %%% <<< MODIFICATION END
    
    fprintf('    Starting adaptive iterations (Max %d)...\n', max_iter);
    
    % Iterative Adaptation Loop (Starts with Q initialized by ISTA)
    for iter = 1:max_iter
        Q_old = Q;
        
        % 1. Calculate Q similarity matrix
        Q_abs = abs(Q);
        Q_diff_sq_matrix = pdist2(Q_abs, Q_abs).^2;
        
        % 2. Estimate sigma_Q adaptively
        valid_diffs = Q_diff_sq_matrix(Q_diff_sq_matrix > eps);
        if isempty(valid_diffs)
            sigma_Q_sq = eps;
        else
            sigma_Q_sq = mean(valid_diffs) + eps;
        end
        
        % 3. Construct Adaptive Graph Weights (W)
        W = exp(-dist_sq_matrix / sigma_x_sq - Q_diff_sq_matrix / sigma_Q_sq);
        W = W - diag(diag(W)); 
        
        % 4. Calculate Graph Laplacian (L)
        D = diag(sum(W, 2));
        L = D - W; 
        L = (L + L') / 2;
        
        % 5. Optimization Step
        A = HtH + lambda * L;
        
        try
            Q = A \ HtP;
        catch ME
            warning('MR-NAH Iter %d: Matrix inversion failed (%s). Trying pinv.', iter, ME.message);
            Q = pinv(A) * HtP;
        end
        
        % 6. Check Convergence
        norm_Q_old = norm(Q_old);
        if norm_Q_old < eps
            change_Q = norm(Q - Q_old);
        else
            change_Q = norm(Q - Q_old) / norm_Q_old;
        end
        
        if mod(iter, 10) == 0
            fprintf('    MR-NAH Iter %d: Change in Q = %.4e (SigmaQ^2=%.3e)\n', iter, change_Q, sigma_Q_sq);
        end

        if change_Q < tol
            fprintf('    MR-NAH: Converged at iteration %d (Change < %.1e).\n', iter, tol);
            break;
        end
    end
    
    if iter == max_iter
        fprintf('    MR-NAH: Reached maximum iterations.\n');
    end

    Q_final = Q;
    residual = norm(H * Q - P_meas) / norm_P;
    
    info = struct();
    info.message = sprintf('MR-NAH finished (Iter %d)', iter);
    info.iterations = iter;
    info.relative_residual = residual;
    
    fprintf(' -> Exiting manifold_regularization_solver. RelRes=%.4f\n', residual);
end

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  >>> HELPER FUNCTIONS <<<                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ... (Keep all existing helper functions) ...

%%% >>> MODIFICATION START: Insert New BAM-H Functions

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                  >>> HELPER FUNCTIONS <<<                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ... (Keep other existing helper functions, e.g., BAM_H_Solver, TMM, etc.) ...

function materials = create_material_properties_with_uncertainty()
    % Creates material database including uncertainty ranges for BAM-H.
    % It attempts to call the base 'create_material_properties' for defaults, 
    % otherwise uses internal fallback definitions.
    
    % --- Load base properties first ---
    % Check if the base function exists as a file (exist returns 2 for a file)
    if exist('create_material_properties', 'file') == 2
        try
            materials = create_material_properties(); 
        catch ME_base
            fprintf('Failed to execute create_material_properties(): %s. Using internal fallback definitions.', ME_base.message);
            materials = define_fallback_materials();
        end
    else
        % If the base function doesn't exist, use internal fallback definitions.
        fprintf('INFO: Base function create_material_properties() not found. Using internal fallback definitions.\n');
        materials = define_fallback_materials();
    end
    
    % =================================================
    % Define Uncertainty Ranges (Priors) for BAM-H
    % =================================================
    
    % --- Pine Bark ---
    if isfield(materials, 'pine_bark')
        % Bark is highly variable.
        materials.pine_bark.c_range = [400, 1000];    % Sound speed range (m/s)
        materials.pine_bark.rho_range = [400, 800];   % Density range (kg/m^3)
    end
    
    % --- Teflon (PTFE) ---
    %%% >>> CORRECTION: Ensure Teflon Ranges are defined
    if isfield(materials, 'teflon')
        % Teflon properties are generally more consistent than bark. We use a tighter range.
        % Assuming typical ranges around c=725, rho=2200.
        materials.teflon.c_range = [650, 800];      % Sound speed range (m/s)
        materials.teflon.rho_range = [2100, 2300];  % Density range (kg/m^3)
    end
    %%% <<< END CORRECTION
end

function materials = define_fallback_materials()
    % Fallback definitions if create_material_properties is missing
    materials = struct();
    % Air
    materials.air.c = 343.0; materials.air.rho = 1.225; materials.air.alpha_dB_m = 0.01; materials.air.alpha_freq_Hz = 5000; materials.air.alpha_power = 1.8;
    
    % Default Pine Bark (Approximation)
    materials.pine_bark.c = 600; materials.pine_bark.rho = 600; materials.pine_bark.alpha_dB_m = 100; materials.pine_bark.alpha_freq_Hz = 10000; materials.pine_bark.alpha_power = 1.5;
    
    % Default Teflon (Based on typical values used previously)
    materials.teflon.c = 725; materials.teflon.rho = 2200; materials.teflon.alpha_dB_m = 50; materials.teflon.alpha_freq_Hz = 1e6; materials.teflon.alpha_power = 1.5;
end

% ... (Keep the BAM_H_Solver and other helper functions below this) ...

function [Q_final, info] = BAM_H_Solver(P_meas, omega, params, base_layer_info, mic_points, esm_points)
    % Bayesian Adaptive Matched-Field Holography (BAM-H) Solver

    N_mc = params.bamh_N_mc_samples;
    N_esm = size(esm_points, 1);
    N_mic = size(mic_points, 1);
    material_name = base_layer_info.layer_material_name;
    mat_db = params.material_database;
    
    if ~isfield(mat_db.(material_name), 'c_range')
        error('BAM-H requires uncertainty ranges (c_range, rho_range) defined for material: %s', material_name);
    end
    
    fprintf('   Sampling %d realizations of the medium (%s)...\n', N_mc, material_name);
    
    % 1. Monte Carlo Sampling (Uniform Prior)
    c_range = mat_db.(material_name).c_range;
    rho_range = mat_db.(material_name).rho_range;
    
    M_samples = struct('c', {}, 'rho', {}, 'log_evidence', {});
    H_tensor = complex(zeros(N_mic, N_esm, N_mc)); % Pre-allocate H storage
    
    % Normalize P_meas for stable evidence calculation (Bartlett proxy)
    norm_P = norm(P_meas);
    if norm_P < eps, error('P_meas is zero.'); end
    P_norm_vec = P_meas / norm_P;

    % Note: This loop can be parallelized using 'parfor' if needed.
    for k = 1:N_mc
        % Sample parameters
        c_k = c_range(1) + rand() * (c_range(2) - c_range(1));
        rho_k = rho_range(1) + rand() * (rho_range(2) - rho_range(1));
        M_samples(k).c = c_k;
        M_samples(k).rho = rho_k;
        
        % 2. Calculate Propagator H(M_k)
        layer_info_k = base_layer_info;
        % Update the database entry for this realization
        layer_info_k.db.(material_name).c = c_k;
        layer_info_k.db.(material_name).rho = rho_k;
        
        % Calculate H_esm (using TMM for speed, as k-Wave is too slow here)
        % This requires Green_matrix_multilayer_TMM to be available.
        try
            [G_esm_cell, ~, N_valid] = Green_matrix_multilayer_TMM(mic_points, esm_points, omega, layer_info_k);
        catch ME_tmm
             warning('TMM calculation issue in BAM-H sample %d: %s. Skipping sample.', k, ME_tmm.message);
             G_esm_cell = []; N_valid = 0;
        end

        if isempty(G_esm_cell) || N_valid ~= N_esm
            H_tensor(:,:,k) = NaN;
            M_samples(k).log_evidence = -Inf;
            continue;
        end
        H_k = G_esm_cell{1};
        H_tensor(:,:,k) = H_k;
        
        % 3. Estimate Model Evidence P(P_meas | M_k)
        % We use the projection of P_meas onto the subspace spanned by H_k (Bartlett proxy).
        
        % Use SVD for robust subspace projection
        [U_k, S_k, ~] = svd(H_k, 'econ');
        s_k = diag(S_k);
        
        % Robust rank estimation
        tol = norm(H_k, 'fro') * 1e-6; % Adjusted tolerance for typical NAH scales
        rank_k = sum(s_k > tol);
        
        if rank_k == 0
            projection_k = 0;
        else
            U_subspace = U_k(:, 1:rank_k);
            % Evidence proxy = || U_subspace' * P_norm_vec ||^2
            projection_k = norm(U_subspace' * P_norm_vec)^2;
        end
        
        M_samples(k).log_evidence = log(projection_k + eps);
    end
    
    % 4. Calculate Posterior Weights for Media
    log_evidences = [M_samples.log_evidence];
    valid_indices = isfinite(log_evidences);
    
    if sum(valid_indices) == 0
        error('BAM-H: All Monte Carlo samples failed during propagator calculation or evidence estimation.');
    end
    
    log_evidences_valid = log_evidences(valid_indices);
    N_mc_valid = sum(valid_indices);

    % Normalize weights robustly (Log-Sum-Exp trick to prevent overflow/underflow)
    max_log_E = max(log_evidences_valid);
    weights_valid = exp(log_evidences_valid - (max_log_E + log(sum(exp(log_evidences_valid - max_log_E)))));
    
    if sum(weights_valid) < eps || any(isnan(weights_valid))
        warning('BAM-H evidence calculation unstable. Falling back to uniform weights.');
        weights_valid = ones(1, N_mc_valid) / N_mc_valid;
    end

    % 5. Weighted Bayesian Source Localization
    % Solve an augmented SBL problem:
    % P_aug = [sqrt(w_1)*P_meas; sqrt(w_2)*P_meas; ...]
    % H_aug = [sqrt(w_1)*H_1; sqrt(w_2)*H_2; ...]
    
    fprintf('   Constructing augmented system for weighted SBL (%d valid samples)...\n', N_mc_valid);
    P_aug = complex(zeros(N_mic * N_mc_valid, 1));
    H_aug = complex(zeros(N_mic * N_mc_valid, N_esm));
    
    H_tensor_valid = H_tensor(:,:,valid_indices);

    for k = 1:N_mc_valid
        idx_start = (k-1)*N_mic + 1;
        idx_end = k*N_mic;
        sqrt_w_k = sqrt(weights_valid(k));
        
        % Use the original P_meas here for the SBL input
        P_aug(idx_start:idx_end) = sqrt_w_k * P_meas;
        H_aug(idx_start:idx_end, :) = sqrt_w_k * H_tensor_valid(:,:,k);
    end
    
    % Run SBL on the augmented system
    fprintf('   Running SBL on the augmented system (Size %dx%d)...\n', size(H_aug,1), size(H_aug,2));
    sbl_params = params; 
    sbl_params.esm_sbl_max_iter = params.bamh_sbl_max_iter;
    sbl_params.esm_sbl_plot = false; % Disable plotting for internal SBL
    
    % Requires sparse_bayesian_learning_original function to be available
    [Q_final, ~, ~, ~, sbl_info] = sparse_bayesian_learning_original(H_aug, P_aug, sbl_params.esm_sbl_max_iter, sbl_params);
    
    % 6. Result Analysis and Optimization
    % Identify the Posterior Mean medium parameters (The optimized estimate of the bark)
    M_samples_valid = M_samples(valid_indices);
    c_optimized = sum([M_samples_valid.c] .* weights_valid);
    rho_optimized = sum([M_samples_valid.rho] .* weights_valid);
    
    fprintf('   BAM-H Optimized Medium Parameters: c=%.2f m/s, rho=%.2f kg/m^3\n', c_optimized, rho_optimized);
    
    % Calculate the final residual and H_r using the optimized (posterior mean) medium parameters
    layer_info_opt = base_layer_info;
    layer_info_opt.db.(material_name).c = c_optimized;
    layer_info_opt.db.(material_name).rho = rho_optimized;
    
    [G_esm_opt_cell, ~, ~] = Green_matrix_multilayer_TMM(mic_points, esm_points, omega, layer_info_opt);
    H_esm_opt = G_esm_opt_cell{1};
    
    relative_residual = norm(H_esm_opt * Q_final - P_meas) / norm(P_meas);
    
    % Calculate H_r for visualization using the optimized parameters
    [G_r_opt_cell, ~, ~] = Green_matrix_multilayer_TMM(params.recon_points, esm_points, omega, layer_info_opt);
    H_r_opt = G_r_opt_cell{1};

    info = struct();
    info.message = sprintf('BAM-H finished (MC=%d, SBL Iter=%d)', N_mc_valid, sbl_info.iterations);
    info.relative_residual = relative_residual;
    info.c_optimized = c_optimized;
    info.rho_optimized = rho_optimized;
    info.H_r_optimized = H_r_opt;
    info.weights = weights_valid;
    info.M_samples = M_samples_valid;
end
%%% <<< MODIFICATION END


